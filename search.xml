<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery不过如此？]]></title>
    <url>%2F2018%2F04%2F27%2FjQuery%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 你说我该如何学习jQuery？这个……先学着先吧！ ★你是几个意思◇我要封装一个函数​ 哦！你是要写个函数，对吧！ ◇我要一个命名空间​ 我想，你要为一个对象取一个名字，是不是，小白？如果是的话，叫「小花」不错，我表示强烈建议！就像是这样： 12var 小花 = &#123;&#125;小花.getWechat() 这个小花就是「命名空间」，旗下有个要自己实现的「得到小花微信号」的方法 如果要关联jQuery的话，那就这样： 123var dom = &#123;&#125;dom.getSibling(node) //得到节点的兄弟姐妹元素dom.addClass(node, &#123;a: true,b: false&#125;) //根据true/false,为节点添加类名 ​ 这里的dom同样是个命名空间，把封装好的函数，取其函数名，放在dom下面，那么，这个命名空间才有它存在的意义。其实说白了，命名空间就是个对象呗！这个对象，给了函数，生活的空间。所以你应该知道你要的是什么了吧！ ◇我需要一个API我觉得你是想要一个别人提供给你用的函数 ★我需要一些套路◇封装一个函数的正确姿势 随意起名 理清输入输出 改个好听的名字 ◇优化代码 如果出现类似的demo就存在优化的可能 ★jQuery是啥？我不知道◇自己封装两个函数得到节点item3的兄弟姐妹1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;ul&gt; &lt;li id="item1"&gt;选项1&lt;/li&gt; &lt;li id="item2"&gt;选项2&lt;/li&gt; &lt;li id="item3"&gt;选项3&lt;/li&gt; &lt;li id="item4"&gt;选项4&lt;/li&gt; &lt;li id="item5"&gt;选项5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function getSiblings(node) &#123; // 得到爸爸的所有的儿子，包括我 var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125; console.log(getSiblings(item3)) //&#123;0: li#item1, 1: li#item2, 2: li#item4, 3: li#item5, length: 4&#125; &lt;/script&gt;&lt;/body&gt; 给节点item3添加3个class 第一种方式：简单直接法 1234567// 添加类a、b、c//简单粗暴添加item3.classList.add('a')item3.classList.add('b')item3.classList.add('c')// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第二种方式：遍历添加法 1234567 //通过数组的方式 var classArray = ['a','b','c'] classArray.forEach(value =&gt; &#123; item3.classList.add(value) &#125;);// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第三种方式：集「添加和移除」于一身法 123456789101112131415 // 第3种更强大法： var classHash = &#123; 'a' : true, 'b' : false, 'c' : true &#125; for(let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;//&lt;li id="item3" class="a c"&gt;选项3&lt;/li&gt; 封装为函数 得到封装好的addClass： 1234567891011function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;&#125;addClass(item3, classHash) ◇优化addClass你是一个对象，想要调用一个方法，有两个姿势： 12obj.x()obj['x']() 所以可有： 12345678function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] var methodName = value ? 'add' : 'remove' node.classList[methodName](key) &#125;&#125;addClass(item3, classHash) ◇关联这两个API为什么需要关联?​ 这两个API都是在操作节点，一个是得到节点的兄弟姐妹；一个是为节点添加/移除class。而DOM的API都在document旗下。所以，依葫芦画瓢，我们同样也可以这样做。 如何关联？​ 在window旗下，命名一个叫小花的空间，然后在小花旗下，绑定这两个API 12345window.小花 = &#123;&#125;小花.getSiblings = getSiblings小花.addClass = addClass小花.getSiblings(item3)小花.addClass(item3, &#123; a: true, b: false, c: true &#125;) 为什么要用「小花」这个命名空间？ 这两个API谁写的？翠花写的，你确定？ 我写了几十个API，厉害吧！厉害，我每次要用你API的时候，都不知去哪儿找，就像是无招牌的店，听说有家店做的「藤条焖猪肉」特别好吃，可是在哪？ 为什么，我引入你写的API，我写的那些demo，出bug了，即把人家的全局变量给覆盖了。他人，一定发誓，我一定不会再用你写的API了，发誓三连…… 用了命名空间，就不会让声明式的函数写法，覆盖了他人的全局变量 ◇能不能把 node 放在前面比如说这样： 12node.getSiblings()node.addClass() 给出两种方法 第一种扩展 Node 接口​ 直接在 Node.prototype 上加函数，函数里this很是关键 12345678910111213141516171819202122Node.prototype.getSiblings = function () &#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;Node.prototype.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; this.classList.add(value) &#125;);&#125;item3.addClass(['a', 'b', 'c'])console.log(item3.getSiblings()) ​ 如果你不能理解这个this表示的是什么，可以这样： 12item3.addClass.call(item3,['a','b','c'])console.log(item3.getSiblings.call(item3)) call()的第一个参数，就是this。有些时候，demo虽然简洁了许多，可是理解起来也会难上几分，就如这个this一样，调用函数是方便了，可是却不好理解这个this，为啥指向调用者？ 请记住：this是call的第一个参数。 你他妈不明白this是因为你他妈不用call 第二种新的接口 BetterNode​ 从构造函数着手，Node的升级版，也叫「无侵入」 12345678910111213141516171819202122232425262728293031// Node的升级版：window.Node2 = function (node) &#123; return &#123; getSiblings: function () &#123; var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125;, addClass: function (classArray) &#123; classArray.forEach(value =&gt; &#123; node.classList.add(value) &#125;); &#125; &#125;&#125;var node2 = Node2(item3)console.log(node2.getSiblings())node2.addClass(['a', 'b', 'c'])console.dir(node2) ◇把 Node2 改个名字吧如这样： 123456789101112131415function jQuery(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById('x')let node2 =jQuery(node)node2.getSiblings()node2.addClass() ◇再给个缩写吧 alias1window.$ = jQuery ◇改进jQuery可传入选择器字符串12345678910111213window.jQuery = function (nodeOrSelector) &#123; let node // 特性检测 if(typeof nodeOrSelector === 'string') &#123; node = document.querySelector(nodeOrSelector) &#125; else &#123; node = nodeOrSelector &#125; return &#123; getSiblings: function () &#123;……&#125;, addClass: function (classArray) &#123;……&#125; &#125;&#125; ​ 这里用到了闭包，getSiblings和addClass都用到了node，那么它们就构成了一个闭包。不会说，你调用了这个jQuery函数完毕后，然后局部变量node存储的值就被释放掉了，由于这个局部变量跟返回值对象中的任意一个方法（或者说是函数）构成了闭包，这意味着就像是「全职猎人中酷拉比卡为了获取强大的力量，把它念能力实质化的锁链，跟自己的心脏绑在一起了」。如果释放掉，那么这个对象返回值，没有任何意义。「没有把念能力跟自己的心脏绑定在一起，就无法获得强大的力量，何谈去复仇旅团呢？」 就像是这样： 有时候，你问为什么局部变量没有被释放掉？回答说「闭包」啊！可是你依旧产生了质疑，如「函数调用栈不是入栈然后出栈吗？一念生一念死，为啥还会有记忆……」。其实你可以反问自己，「为啥调用函数的时候，会有调用栈的概念？」「为啥调用函数的时候，会有闭包的概念？」 他妈的说白了「概念不会凭空产生，它的存在总有它存在的意义，也许合理也许不合理，它总有一个理由，占着茅坑不搞事」，简而言之，就是「哥的世界你不懂，45度角仰望天空……」 如果你觉得复杂了，就是没有想清楚 如果你觉得闭包很复杂，那么我想你需要静静，不要去想它…… 操纵多个节点123456789101112131415161718192021222324252627282930window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123;&#125; //类型检测： if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) //伪数组 for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; nodes.getSiblings = function () &#123; &#125; nodes.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(value) &#125; &#125;) &#125; return nodes&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue']) 添加读写文本的API123456789101112131415161718nodes.text = function (text) &#123; if (text === undefined) &#123; var texts = [] for (let i = 0; i &lt; nodes.length; i++) &#123; texts.push(nodes[i].textContent) &#125; return texts &#125; else &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text &#125; &#125;&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue'])console.log(node2.text())node2.text('hi') ★jQuery初探◇调用jQuery这个函数jQuery是框架还是库？ Framework 帮你设计架构，而 library 帮你写代码。所以jQuery是库，不是框架。 初始化网页文档：要引入jQuery库 骨架： 123456789&lt;body&gt;&lt;ul&gt; &lt;li&gt;第1项数&lt;/li&gt; &lt;li&gt;第2项数&lt;/li&gt; &lt;li id='item3'&gt;第3项数&lt;/li&gt; &lt;li&gt;第4项数&lt;/li&gt; &lt;li&gt;第5项数&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 行为： 1234var nodes = jQuery('ul&gt;li')console.dir(nodes)var dd = jQuery()console.dir(dd) 结果： 可见这个jQuery库是把其API写到Object的原型里去的，这样一来就不用浪费资源了 ◇依旧可以使用DOM API 行为： 123var item3 = jQuery('#item3')console.dir(item3)item3[0].classList.add('blue') 只不过jQuery返回的是伪数组，所以你需要添加下标才可以，不过即便如此，我想你也不想用DOM API了吧！ ◇使用一些API 添加类、移除类：只是追加，不会覆盖掉原来的。移除后回到默认的蓝色 12item3.addClass('red')item3.removeClass('red') 链式操作：移除单前类，再添加，相当于是覆盖； 12item3.removeClass('blue').addClass('red')item3.removeClass('red') 移除红色后，没有回到蓝色 开关 添加2个button元素： 12&lt;button id='x'&gt;X&lt;/button&gt;&lt;button id='y'&gt;Y&lt;/button&gt; 鼠标点击按钮，就会切换item3的字体颜色： 123x.onclick = function() &#123; item3.toggleClass('yellow')&#125; 效果就像是，天黑开灯，睡觉关灯 为多个元素添加不同的类： 1234567var classes = ['blue','red','yellow','green','yellowgreen']y.onclick = function() &#123; nodes.addClass(function(index,currentClass) &#123; return classes[index] &#125;)&#125; ★jQuery不过如此？ jQuery 在兼容性方面做得很好，1.7 版本兼容到 IE 6 jQuery 还有动画、AJAX 等模块，不止 DOM 操作 jQuery 的功能更丰富 jQuery 使用了 prototype，我们没有使用，需要new的知识点 ★总结 在非迫不得的情况下，不需要自己写操作的页面API，毕竟你没有jQuery做的好，如兼容问题 如果要想操作页面，目前jQuery就能很好地满足，其它同类型的库没有必要引入 拿到一个节点或多个节点，然后调用API，我想这就是使用jQuery 如果是jQuery对象，那么接收的变量最好加上个\$，以免混淆 了普通的DOM对象，如 var $node = jQuery(&#39;ul&gt;li&#39;) 如何看jQuery文档？先记住一些常见的关于其API的单词，然后学会一个API如何使用后，根据需求去使用API。如果没有理解这个API关于中文的概述，那么试着看看它的英文 jQuery很不简单，但我们的使用是简单的，不然，也不会红了那么多年 ★参考资料jQuery 是库（library）还是框架(framework)? jQuery中.addClass()和.removeClass()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个jQuery的API]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjQuery%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[★引子​ 经常用jQuery库的API，真的好吗？为何自己不尝试着实现一个jQuery的API…… ★想要实现的功能 将当前文档中所有 div 的 class 都添加一个 red 将当前文档中所有 div 的 textContent都 变为 hi ★如何实现◇搞一个基本的测试骨架12345&lt;div&gt;我是1div&lt;/div&gt;&lt;div&gt;我是2div&lt;/div&gt;&lt;div&gt;我是3div&lt;/div&gt;&lt;div&gt;我是4div&lt;/div&gt;&lt;div&gt;我是5div&lt;/div&gt; ◇给上简单的皮肤12345&lt;style&gt; .red &#123; color: red; &#125;&lt;/style&gt; ◇按你想要的实现行为定义一个全局变量1window.jQuery = function (nodeOrSelector) &#123;&#125; 这个全局变量是个函数，形式参数可为「节点」或「选择器」，总而言之即是可传入节点对象或字符串。 之所以定义一个去全局变量，是为了有个命名空间，好让自己所写的API都归于jQuery旗下 开搞函数体声明一个局部变量1let nodes = &#123;&#125; 这个局部变量很重要，它是个伪数组 特性检测123456789101112if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length&#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125;&#125; 需要判断传入的参数是啥类型的？假如是字符串，注意这个字符串是选择器，根据选择器得到一个节点组成的伪数组，遍历它，把它扔到局部变量里去，这样就可以砍掉多余的NodeList接口 如果实参是Node的实例的话，那么nodes就只有一个元素了 添加「addClass」API12345nodes.addClass = function (className) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].classList.add(className) &#125;&#125; 添加「setText」API12345nodes.setText = function (text) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].textContent = text &#125;&#125; 返回值1return nodes ◇测试写的API12345window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 这里搞了个别名$ 「实现一个jQuery的API」的github源码 ★总结 实现两个API是否用到了闭包 我是用this访问的，所以没用到闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
