<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[let，更好的var？]]></title>
    <url>%2F2018%2F04%2F30%2Flet%EF%BC%8C%E6%9B%B4%E5%A5%BD%E7%9A%84var%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 我就喜欢，直接用元素的「id」作为DOM对象。这样操作极其方便，不用每次都要「document.get……」，这让我少写了许多个字符。难道这样用真得没有bug吗？ ★使绊子​ 你不是很喜欢，用「id」作为DOM对象吗？那好，这个元素的「id」值为「alert」，你猜打印的结果： 12345678910&lt;body&gt; &lt;div id="alert"&gt;Hello!World&lt;/div&gt; &lt;div id="x"&gt;我是「x」&lt;/div&gt; &lt;script&gt; var xHtml = x.textContent var alertHtml = alert.textContent console.log(xHtml) console.log(alertHtml) &lt;/script&gt;&lt;/body&gt; 不是显而易见吗？ 一个是『我是「x」』；一个是「Hello!World」； 你确定？有时候你会存在一些错误的认识，至今未尝发觉，你总以为别人都是这样做的，自己照着做总没错吧！而且也拿到了自己想要的结果，可是你有没有想过，这样用，也许存在「大前提」呢？ 那好吧！我就运行一下，看一下结果，证明小白我是正确的 结果： 12我是「x」undefined 此时此刻的你，大写的一脸懵逼……心里一连串的问号——问号三连 为什么？我不服，我不服……为什么「x」可以，而「alert」却不可以。明明就只有名字不同，难道连名字也是一种罪过吗？ 你打印一下「window」 1console.dir(window) 会发现window旗下并没有「x」这个key，却可以使用「x」 如可以这样： 12window.xwindow['x'] 对于「alert」来说，「alert」一直是全局属性，一直在window旗下 这意味着，如果你想要快捷地用「id」获取DOM对象的话，那么「id值」就不能与window旗下的全局属性冲突 可是window旗下并没有显示「x」这个key啊！却可以使用…… 为什么？没有探究的必要了，在我看来……有些东西不需要如此执着，就比如你这个，你可以假设很多答案，如：「控制台打印的东西有问题」……「window的第一层找不着就到其旗下的document里去找，然后找到」 如果非要找出个所以然，可以看一下stackoverflow的回答： Do DOM tree elements with ids become global variables? ★全局变量可耻，不能用​ 平时用x/y/……等避开了window的属性，才能通过「id值」直接拿到对应的DOM元素对象。可是如果没有避免呢？那该如何拿到这个DOM对象？ ◇无所畏惧，拿到DOM对象​ 随意起了一个名字，叫「alertDom」 12var alertDom = document.getElementById('alert')console.log(alertDom) 这是通过DOM提供的API拿到的对象，还以其它API也可以拿到，如： 12var alertDom1 = document.querySelector('#alert')console.log(alertDom1) ◇有所畏惧，alert()不能用了​ 我声明了一个变量叫「alert」 123var alert = document.getElementById('alert')console.log(alert)alert('你能看到我吗？') 结果报错了： alert is not a function 这个声明的变量是全局变量，它与window旗下的alert冲突了，说白了，就是覆盖了它 所以，你还是不要用全局变量好了，起个名字真费劲 ★全局变量？局部变量◇唯函数，方能成为局部变量​ 我们可以使用局部变量，以防和window的全局属性冲突了 123456function y() &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;y()console.log(window.alert) 可见全局的alert依旧是它，同时我们也得到了想要的alert值，即这个#alert元素 可是问题又来了，关于函数的名字，函数的名字也是全局变量啊！它也会存在冲突的可能性的 一个问题套着一个问题，如此反复…… ◇被忽视的函数名​ 函数名，作为全局变量的一份子，那么只好去掉了，改为匿名函数。可是如何调用匿名函数呢？难道还是这样子么 var fn = function(){}？这岂不是进入死循环了啊！ ★立即执行函数表达式（IIFE）◇立即执行函数​ 函数匿名了，可以立即执行吗？ 1234function() &#123; var alert = document.querySelector('#alert') console.log(alert)&#125; () 结果，报语法错误： Unexpected token ( 为什么？ 注意，这是前面的function()出错先 当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。 注意： var foo = function(){console.log(1)}()这样是可以立即调用的 如果是有名字的函数声明，然后立即调用呢 function foo(){ /* code */ }();//SyntaxError: Unexpected token 为什么？ 当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。 毕竟圆括号里并没有表达式，你直接敲下 ()也是会报语法错误的 那加个参数，可以吧 12345678//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：function foo()&#123;/* code */&#125;(1)//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:function foo()&#123;/* code */&#125;(1); 具体测试一下： 123456789101112131415161718var a = function foo(f)&#123; console.log(f);return f&#125;(1); //1console.log(a) //1var b = function foo(f)&#123; console.log(f)&#125;(1);console.log(b) //undefinedfunction foo()&#123; console.log(1)&#125;(2); //2function foo(f)&#123; console.log(f);console.log(3)&#125;(2); //2var k = function zzz(f)&#123;console.log(5);console.log(f);return 7&#125;(3)//5 3k //7var q = function qqq(f)&#123;console.log(5);console.log(f+1);return 7&#125;(3)//5 4q //7var t = function foo(f)&#123; console.log(f)&#125;(1);//1t //undefinedvar z = function(f)&#123;return f&#125;(5)z //5 ◇立即执行函数表达式​ 如何去掉匿名函数立即执行的语法错误？错误的本质在于，语法分析器看到了 function这个关键字，于是认为，你这个函数声明是没有名字的啊！于是就报错了 如何解决？ 将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。 所以可有： 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。 当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。 测试demo： 12345678(function () &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;)()(function () &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;()) 注意：括号放在哪也是有区别的，虽然结果一致 前者是「括号内的表达式代表函数表达式」 后者是「括号内的表达式代表函数立即调用表达式」 可见，函数名字没了，局部变量有了，而且还有立即调用 除了添加圆括号，还有别的方式吗？ 如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节 1234!function()&#123;/* code */&#125;();~function()&#123;/* code */&#125;();-function()&#123;/* code */&#125;();+function()&#123;/* code */&#125;(); ★使用let​ JavaScript很奇葩，为了使用局部变量，需要搞个函数，然后还要匿名，还要立即执行，立即执行报语法错误，于是，还得告诉浏览器我这个函数不是声明的 为此，JavaScript升级了 理论上，在JavaScript眼中，demo块是没有作用域的，但是升级了，就有作用域了。这个作用域的有无，是「let」和「var」决定的，即let眼中是有的，而var则无视 测试demo： 1234567891011// var的姿势：&#123; var alert = document.querySelector('#alert') console.log(alert)&#125;// 等价于：var alert&#123; alert = document.querySelector('#alert') console.log(alert)&#125; 这个alert还是会跑出去，成为一个全局变量，把window的alert给覆盖了，即「块」是包不住var的，于是就用了IIFE 而let是怎样的呢？ 123456789101112131415&#123; let alert = document.querySelector('#alert') console.log(alert)&#125;&#123; let a = 1&#125;// console.log(a)//a is not defined let b = 2&#123; let b = 3&#125;console.log(b)//2 ​ let的姿势：let也不会提升，在哪声明就在哪声明，不会变量提升；能认识这个let只有在这个块里面了，出了这个块就没人认识它了 ES6之前想要用局部变量，只好用立即执行函数表达式了，ES6出来后就，不需要了，毕竟有let这个神器 ★总结 若对元素设置id属性，值为「x」的话，那么可以通过window.x或者window[&#39;x&#39;]引用该元素，而不是使用DOM的API去获取该元素的DOM对象，而且这用的用法写入了html5规范 最好不要使用全局变量，毕竟很容易导致命名冲突，或者说是变量污染 要想使用好局部变量，用两种方式可以做到：一是立即执行函数表达式（IIFE）；二是使用ES6的语法let 一个这样的问题「直接拿元素id的值，并没有得到该元素的DOM对象」引发出了，好几个知识点，如「let和var」、「IIFE」、「function关键字」…… 若是放表达式的圆括号 ()，必须给上表达式，不然会报语法错误 ★参考资料 DOM概述 DOM对象 [译] JavaScript：立即执行函数表达式（IIFE） 直接使用id引用DOM元素 为什么要有js立即执行函数，存在的意义是什么？ JavaScript中var、let、const区别？ 函数声明和函数表达式的区别 ★demo链接 使用let的测试demo]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery不过如此？]]></title>
    <url>%2F2018%2F04%2F27%2FjQuery%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 你说我该如何学习jQuery？这个……先学着先吧！ ★你是几个意思◇我要封装一个函数​ 哦！你是要写个函数，对吧！ ◇我要一个命名空间​ 我想，你要为一个对象取一个名字，是不是，小白？如果是的话，叫「小花」不错，我表示强烈建议！就像是这样： 12var 小花 = &#123;&#125;小花.getWechat() 这个小花就是「命名空间」，旗下有个要自己实现的「得到小花微信号」的方法 如果要关联jQuery的话，那就这样： 123var dom = &#123;&#125;dom.getSibling(node) //得到节点的兄弟姐妹元素dom.addClass(node, &#123;a: true,b: false&#125;) //根据true/false,为节点添加类名 ​ 这里的dom同样是个命名空间，把封装好的函数，取其函数名，放在dom下面，那么，这个命名空间才有它存在的意义。其实说白了，命名空间就是个对象呗！这个对象，给了函数，生活的空间。所以你应该知道你要的是什么了吧！ ◇我需要一个API我觉得你是想要一个别人提供给你用的函数 ★我需要一些套路◇封装一个函数的正确姿势 随意起名 理清输入输出 改个好听的名字 ◇优化代码 如果出现类似的demo就存在优化的可能 ★jQuery是啥？我不知道◇自己封装两个函数得到节点item3的兄弟姐妹1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;ul&gt; &lt;li id="item1"&gt;选项1&lt;/li&gt; &lt;li id="item2"&gt;选项2&lt;/li&gt; &lt;li id="item3"&gt;选项3&lt;/li&gt; &lt;li id="item4"&gt;选项4&lt;/li&gt; &lt;li id="item5"&gt;选项5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function getSiblings(node) &#123; // 得到爸爸的所有的儿子，包括我 var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125; console.log(getSiblings(item3)) //&#123;0: li#item1, 1: li#item2, 2: li#item4, 3: li#item5, length: 4&#125; &lt;/script&gt;&lt;/body&gt; 给节点item3添加3个class 第一种方式：简单直接法 1234567// 添加类a、b、c//简单粗暴添加item3.classList.add('a')item3.classList.add('b')item3.classList.add('c')// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第二种方式：遍历添加法 1234567 //通过数组的方式 var classArray = ['a','b','c'] classArray.forEach(value =&gt; &#123; item3.classList.add(value) &#125;);// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第三种方式：集「添加和移除」于一身法 123456789101112131415 // 第3种更强大法： var classHash = &#123; 'a' : true, 'b' : false, 'c' : true &#125; for(let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;//&lt;li id="item3" class="a c"&gt;选项3&lt;/li&gt; 封装为函数 得到封装好的addClass： 1234567891011function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;&#125;addClass(item3, classHash) ◇优化addClass你是一个对象，想要调用一个方法，有两个姿势： 12obj.x()obj['x']() 所以可有： 12345678function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] var methodName = value ? 'add' : 'remove' node.classList[methodName](key) &#125;&#125;addClass(item3, classHash) ◇关联这两个API为什么需要关联?​ 这两个API都是在操作节点，一个是得到节点的兄弟姐妹；一个是为节点添加/移除class。而DOM的API都在document旗下。所以，依葫芦画瓢，我们同样也可以这样做。 如何关联？​ 在window旗下，命名一个叫小花的空间，然后在小花旗下，绑定这两个API 12345window.小花 = &#123;&#125;小花.getSiblings = getSiblings小花.addClass = addClass小花.getSiblings(item3)小花.addClass(item3, &#123; a: true, b: false, c: true &#125;) 为什么要用「小花」这个命名空间？ 这两个API谁写的？翠花写的，你确定？ 我写了几十个API，厉害吧！厉害，我每次要用你API的时候，都不知去哪儿找，就像是无招牌的店，听说有家店做的「藤条焖猪肉」特别好吃，可是在哪？ 为什么，我引入你写的API，我写的那些demo，出bug了，即把人家的全局变量给覆盖了。他人，一定发誓，我一定不会再用你写的API了，发誓三连…… 用了命名空间，就不会让声明式的函数写法，覆盖了他人的全局变量 ◇能不能把 node 放在前面比如说这样： 12node.getSiblings()node.addClass() 给出两种方法 第一种扩展 Node 接口​ 直接在 Node.prototype 上加函数，函数里this很是关键 12345678910111213141516171819202122Node.prototype.getSiblings = function () &#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;Node.prototype.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; this.classList.add(value) &#125;);&#125;item3.addClass(['a', 'b', 'c'])console.log(item3.getSiblings()) ​ 如果你不能理解这个this表示的是什么，可以这样： 12item3.addClass.call(item3,['a','b','c'])console.log(item3.getSiblings.call(item3)) call()的第一个参数，就是this。有些时候，demo虽然简洁了许多，可是理解起来也会难上几分，就如这个this一样，调用函数是方便了，可是却不好理解这个this，为啥指向调用者？ 请记住：this是call的第一个参数。 你他妈不明白this是因为你他妈不用call 第二种新的接口 BetterNode​ 从构造函数着手，Node的升级版，也叫「无侵入」 12345678910111213141516171819202122232425262728293031// Node的升级版：window.Node2 = function (node) &#123; return &#123; getSiblings: function () &#123; var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125;, addClass: function (classArray) &#123; classArray.forEach(value =&gt; &#123; node.classList.add(value) &#125;); &#125; &#125;&#125;var node2 = Node2(item3)console.log(node2.getSiblings())node2.addClass(['a', 'b', 'c'])console.dir(node2) ◇把 Node2 改个名字吧如这样： 123456789101112131415function jQuery(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById('x')let node2 =jQuery(node)node2.getSiblings()node2.addClass() ◇再给个缩写吧 alias1window.$ = jQuery ◇改进jQuery可传入选择器字符串12345678910111213window.jQuery = function (nodeOrSelector) &#123; let node // 特性检测 if(typeof nodeOrSelector === 'string') &#123; node = document.querySelector(nodeOrSelector) &#125; else &#123; node = nodeOrSelector &#125; return &#123; getSiblings: function () &#123;……&#125;, addClass: function (classArray) &#123;……&#125; &#125;&#125; ​ 这里用到了闭包，getSiblings和addClass都用到了node，那么它们就构成了一个闭包。不会说，你调用了这个jQuery函数完毕后，然后局部变量node存储的值就被释放掉了，由于这个局部变量跟返回值对象中的任意一个方法（或者说是函数）构成了闭包，这意味着就像是「全职猎人中酷拉比卡为了获取强大的力量，把它念能力实质化的锁链，跟自己的心脏绑在一起了」。如果释放掉，那么这个对象返回值，没有任何意义。「没有把念能力跟自己的心脏绑定在一起，就无法获得强大的力量，何谈去复仇旅团呢？」 就像是这样： 有时候，你问为什么局部变量没有被释放掉？回答说「闭包」啊！可是你依旧产生了质疑，如「函数调用栈不是入栈然后出栈吗？一念生一念死，为啥还会有记忆……」。其实你可以反问自己，「为啥调用函数的时候，会有调用栈的概念？」「为啥调用函数的时候，会有闭包的概念？」 他妈的说白了「概念不会凭空产生，它的存在总有它存在的意义，也许合理也许不合理，它总有一个理由，占着茅坑不搞事」，简而言之，就是「哥的世界你不懂，45度角仰望天空……」 如果你觉得复杂了，就是没有想清楚 如果你觉得闭包很复杂，那么我想你需要静静，不要去想它…… 操纵多个节点123456789101112131415161718192021222324252627282930window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123;&#125; //类型检测： if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) //伪数组 for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; nodes.getSiblings = function () &#123; &#125; nodes.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(value) &#125; &#125;) &#125; return nodes&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue']) 添加读写文本的API123456789101112131415161718nodes.text = function (text) &#123; if (text === undefined) &#123; var texts = [] for (let i = 0; i &lt; nodes.length; i++) &#123; texts.push(nodes[i].textContent) &#125; return texts &#125; else &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text &#125; &#125;&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue'])console.log(node2.text())node2.text('hi') ★jQuery初探◇调用jQuery这个函数jQuery是框架还是库？ Framework 帮你设计架构，而 library 帮你写代码。所以jQuery是库，不是框架。 初始化网页文档：要引入jQuery库 骨架： 123456789&lt;body&gt;&lt;ul&gt; &lt;li&gt;第1项数&lt;/li&gt; &lt;li&gt;第2项数&lt;/li&gt; &lt;li id='item3'&gt;第3项数&lt;/li&gt; &lt;li&gt;第4项数&lt;/li&gt; &lt;li&gt;第5项数&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 行为： 1234var nodes = jQuery('ul&gt;li')console.dir(nodes)var dd = jQuery()console.dir(dd) 结果： 可见这个jQuery库是把其API写到Object的原型里去的，这样一来就不用浪费资源了 ◇依旧可以使用DOM API 行为： 123var item3 = jQuery('#item3')console.dir(item3)item3[0].classList.add('blue') 只不过jQuery返回的是伪数组，所以你需要添加下标才可以，不过即便如此，我想你也不想用DOM API了吧！ ◇使用一些API 添加类、移除类：只是追加，不会覆盖掉原来的。移除后回到默认的蓝色 12item3.addClass('red')item3.removeClass('red') 链式操作：移除单前类，再添加，相当于是覆盖； 12item3.removeClass('blue').addClass('red')item3.removeClass('red') 移除红色后，没有回到蓝色 开关 添加2个button元素： 12&lt;button id='x'&gt;X&lt;/button&gt;&lt;button id='y'&gt;Y&lt;/button&gt; 鼠标点击按钮，就会切换item3的字体颜色： 123x.onclick = function() &#123; item3.toggleClass('yellow')&#125; 效果就像是，天黑开灯，睡觉关灯 为多个元素添加不同的类： 1234567var classes = ['blue','red','yellow','green','yellowgreen']y.onclick = function() &#123; nodes.addClass(function(index,currentClass) &#123; return classes[index] &#125;)&#125; ★jQuery不过如此？ jQuery 在兼容性方面做得很好，1.7 版本兼容到 IE 6 jQuery 还有动画、AJAX 等模块，不止 DOM 操作 jQuery 的功能更丰富 jQuery 使用了 prototype，我们没有使用，需要new的知识点 ★总结 在非迫不得的情况下，不需要自己写操作的页面API，毕竟你没有jQuery做的好，如兼容问题 如果要想操作页面，目前jQuery就能很好地满足，其它同类型的库没有必要引入 拿到一个节点或多个节点，然后调用API，我想这就是使用jQuery 如果是jQuery对象，那么接收的变量最好加上个\$，以免混淆 了普通的DOM对象，如 var $node = jQuery(&#39;ul&gt;li&#39;) 如何看jQuery文档？先记住一些常见的关于其API的单词，然后学会一个API如何使用后，根据需求去使用API。如果没有理解这个API关于中文的概述，那么试着看看它的英文 jQuery很不简单，但我们的使用是简单的，不然，也不会红了那么多年 ★参考资料jQuery 是库（library）还是框架(framework)? jQuery中.addClass()和.removeClass()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个jQuery的API]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjQuery%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[★引子​ 经常用jQuery库的API，真的好吗？为何自己不尝试着实现一个jQuery的API…… ★想要实现的功能 将当前文档中所有 div 的 class 都添加一个 red 将当前文档中所有 div 的 textContent都 变为 hi ★如何实现◇搞一个基本的测试骨架12345&lt;div&gt;我是1div&lt;/div&gt;&lt;div&gt;我是2div&lt;/div&gt;&lt;div&gt;我是3div&lt;/div&gt;&lt;div&gt;我是4div&lt;/div&gt;&lt;div&gt;我是5div&lt;/div&gt; ◇给上简单的皮肤12345&lt;style&gt; .red &#123; color: red; &#125;&lt;/style&gt; ◇按你想要的实现行为定义一个全局变量1window.jQuery = function (nodeOrSelector) &#123;&#125; 这个全局变量是个函数，形式参数可为「节点」或「选择器」，总而言之即是可传入节点对象或字符串。 之所以定义一个去全局变量，是为了有个命名空间，好让自己所写的API都归于jQuery旗下 开搞函数体声明一个局部变量1let nodes = &#123;&#125; 这个局部变量很重要，它是个伪数组 特性检测123456789101112if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length&#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125;&#125; 需要判断传入的参数是啥类型的？假如是字符串，注意这个字符串是选择器，根据选择器得到一个节点组成的伪数组，遍历它，把它扔到局部变量里去，这样就可以砍掉多余的NodeList接口 如果实参是Node的实例的话，那么nodes就只有一个元素了 添加「addClass」API12345nodes.addClass = function (className) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].classList.add(className) &#125;&#125; 添加「setText」API12345nodes.setText = function (text) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].textContent = text &#125;&#125; 返回值1return nodes ◇测试写的API12345window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 这里搞了个别名$ 「实现一个jQuery的API」的github源码 ★总结 实现两个API是否用到了闭包 我是用this访问的，所以没用到闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
