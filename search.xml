<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[人计算与机器自动计算（上篇）]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BA%BA%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%BA%E5%99%A8%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[愚蠢的人类！颤抖吧！我们机器一族就是闲得慌，不像你们人类，为了方便计算需要找各种计算规则，而且有的复杂的要命！而我们只需要一条简单的规则，就能算出结果了，即便计算量大，可我们就是任性！不差钱！！！ 人计算与机器自动计算（上篇）★「人」计算与「机器」计算的差别？ ◇讲解这张图人计算与机器计算到底有啥差别？通过举个栗子来解释其差别。 求ax^2^ +bx+c=0的根「人」求解关于求一元二次方程的根，我们在初中都学过了，比如有个叫求根公式（把参数带进来，那么其根就出现了，当然这还需要判断这个方程有没有根才可以）的，至于这个公式的推导过程，我早已忘记。 「机器」求解我的天，机器竟然也能求解！如果机器不知道这个求根公式能不能求解，那它还能求解呢？可以，可以采用图上的那种方式——代入法。显然机器可以采用一种笨方法！这让我想起了，几何题里的「求这条边的长度」问题的时候，我用把尺子一量，就写上了答案，这显然也是种笨方法！ 机器这样代入的求解思维和人求解的思维是不太一样的！ 二者的差别第一个： 我们可以使一条规则变得很复杂，但是我们计算量呢？却可能很小。为什么呢？毕竟只需要把方程的系数代入到求根公式里，就可以得到根了。 机器有可能不能处理这么复杂的规则，如求根公式。那该怎么办呢？别忘了，机器是可以使用每条都很简单的规则的，而且这样的机器也是能造出来的。但是这样简单的规则计算起来，它的计算量却很大！可这也正是机器的这样一个特点——我（机器）不怕量大就怕复杂！ 第二个： 人要在求解一元二次方程的根的时候，是必须要知道具体的计算规则的。而这种规则对于机器来讲呢？机器也可以用这种规则，当然我们需要将这种规则转化成一些程序，让机器可以识别！ 第三个： 我们这样一个规则只能求解……「比如说这个求根公式，它只能求解一元二次方程。」，类似于「a~1~x^2^ +a~2~x = c」这种形式，那么对于一般方程来讲，能不能求解呢？ 对于机器求解这种思维来讲，对于这种一般性方程（任意元，任意次的方程。ps:这个长相的请看上方的图），实际上，机器都可以进行求解。 这也说明在有一些问题，数学上还没有给我们找到「求解简单的」这种求解方法的时候，我们可以采取利用简单的规则，让机器来自动的求解。我们说这是一个很重要的、研究自动计算的、这样一个思维 。那么它可以帮助人们解决一些数学上的一些、计算上的一些难题。 ★基本计算规则 vs 程序 vs 机器？ ◇讲解这张图这是用差分法来计算乘方（求n个相同因数乘积的运算，叫做乘方，乘方的结果叫做幂 ），比如我要计算一个数的平方，一般我们都是直接n*n这样计算，但是我们可以通过简单的计算规则，把这个乘方计算出来。那么怎么算呢？这需要给出几个初始值才行，如0的平方0、1的平方1、2的平方4，这几个值是必须要给出来的。接着，后一个数减去前一个数得到一个差分，这个差分我们称为一阶差分。同理，更进一步来看，一阶差分的相减，就得到了二阶差分。 有了初始值和计算差分的方法，那么我们在计算3的平方的时候，就可以这样算了，4+3+2，即上一个数的平分+其对应的一阶差分和二阶差分。这样的一种规则，可以用上图那个公式表示，而这种规则其实是很简单的，即我们只需要减法运算和加法运算，就可以计算出这么一个乘方。 这种规则的特点： 只需要加法运算和乘法运算，就能计算出那么一个乘方 其它运算则可以通过组合加减法运算来实现 除了可以做到乘方以外，还能不能做到其它运算呢？比如说多项式运算 ◇多项式运算 这个同样可以用上面那种规则来算，首先需要事先给出3个初始值才行，如3、6、11，通过这三个初始值的差分计算，可以得到2个一阶差分，借此得到1个二阶差分。那么当x=3的时候，就不需要代入值进去求结果了，直接通过上一次x=2的结果+一阶差分+二阶差分，就可以得到x=3的结果了。 这样一来，求当X等于某一个值的，求该多项式的值的时候，如果以前的多项式求出来了的话，那么加上一阶差分和二阶差分可以得到结果了，如x=6，而你有了当x=4和x=5时，多项式的结果，那么x=6的结果就显而易见了。 ◇总结附上一张完整的图： 这两个例子(乘方运算和多项式运算)都有想通的地方，即只要我们给出初始的值，我们就可以用前一个值+一阶差分+二阶差分，就可以得出后一个值了啊！那么这种计算方法，我们说这是差分法求多项式的值。还有就是大家可以看到，初始值不一样，计算的多项式也是不一样的。 这TM让我想起了递归，而上述的计算规则，恰恰如递归的后半生一样！！！（递归的前半生在找初恋（初始值），后半生则是为与初恋结婚而努力奋斗（得到结婚的结果）） ★差分机能不能根据上述的规则，做出一台机器呢？实际上我们说巴贝奇就是利用这种差分的原理 ，可以实现了求解多项式。这个差分机，用齿轮表示了一些数字，通过齿轮间的啮合「niè hé 」来去表示一些差分运算和这种加法运算。所以他制造了第一台，我们说能够编写一定程序的、可以变化规则的一台计算机，那么这台计算机在计算机历史上是很有意义的。 想要深入了解差分机？就看这篇文章——来看看古老的蒸汽电脑——差分机。我看了一眼，就是两个字——复杂…… ★总结 了解了差分法是什么 简单的规则可以让机器来做，反正机器闲得慌]]></content>
      <categories>
        <category>计算机专业导论</category>
      </categories>
      <tags>
        <tag>差分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么学计算机专业导论？]]></title>
    <url>%2F2018%2F06%2F19%2F%E6%80%8E%E4%B9%88%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%AF%BC%E8%AE%BA%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[继为什么学、学什么后，来到怎么学了……这节会让你明白什么是内功？ ★本门课程与其它课程之间的关系◇其它课程 其它课程内容通常来讲都是横向组织教学内容，比如说集合论与图论，它会一个知识点一个知识点的来给大家进行讲解，比如说讲解图的性质及证明、树的性质及证明、关系的性质及证明等等，我们说这是一种横向的组织。 再比如说数据结构，那么他会讲图的存储与操纵、树的存储与操纵、链表的存储与操纵等等。 ◇本门课程 对于我们这个课程来讲，它是一种纵向组织内容，通过贯通，让大家了解从社会/自然问题，通过我们这些课程的这种知识如何贯通起来，获得社会/自然问题的这样一个结果，使你理解、这种各个知识点的、这样一个作用，因此我们对每一个知识点上并不做横向的延展，而是做纵向的贯通，这是一个很重要的一点的一个概念，也是很重要的特点 ◇总结 我们说横向的这种多少体现了我们知识的一种广度覆盖面。而我们说纵向的这种，即这样一种长短体现了一种深度，本门课程重在深度，而不在每个知识点它的这种细节的讨论。既强调大思维与小细节，强化这种大思维的这种理解，有些小细节不理解没有关系，可能后面我们还会继续学习，但这些知识点贯通就是我们这门课的要做到、要理解的。 ★知识构建次序 那么进一步我们来看，怎样构建计算机学科的一些知识，怎么样构建本门课的知识，因为我们都是初次来学习。 我们来看我们可以按照这种次序来构建。 ◇抽象和自动化 我们说计算机学科最本质的就是抽象和自动化的学习，那么抽象就是学会理解、区分、命名、表达，学会讲现实中的社会/自然问题，表达成我们说计算机、计算机器可以求解的这样一些形式，而自动化就是让机器代替人进行求解，我们要设计、构造和应用这样的机器。 ◇最能代表太极（抽象和自动化）的3个方面 在这个基础（太极）上，最关键的内容，实际上我们说就是体现了三个方面。这三个方面也可以说最能代表抽象与自动化的。 符号化-计算化-自动化 一个呢？我们就是符号化、计算化与自动化，就是我们前面一棵树上的「0和1」的思维 组合-抽象与构造 另外一个呢？就是组合-抽象与构造，这是关于程序和计算系统的思维。我们说计算系统最核心的就是能执行程序的这样一个系统。 迭代与递归 那么第三个讲呢？就是在构造程序的过程当中，最核心的最基本的手段就是迭代和递归 总结 我们说这三种思维是非常重要的思维，我们要先学好，理解透彻以后，我们再来学习下一方面的内容 ◇计算系统 那么进一方面的内容，我们就要理解计算系统、理解机器是如何执行程序的、理解程序被机器执行它的一个原理、理解机器执行程序的一些环境，那么这些方面，无论是我们将来进一步的这种进行程序设计的学习，还是其它课程的学习都很重要。所以在这个方面当中，我们要学习冯诺依曼计算机、个人计算机，进一步延展到并行分布计算环境和云计算环境。 ◇问题求解之算法与程序设计◇网络化思维◇数据化思维◇面向某类学科/方向的计算◇没有内容的这4点概述 那么在此基础上我们要进一步学习的就是问题求解的算法与程序设计，再学习网络化思维，再学习数据化思维。我们说这些思维的学习通常都要结合某一类计算、某一类社会/自然问题，结合起来学习是非常有意义的。所以在这里面来讲，我们说像这些内容：如何结合计算物理学、智能计算、神经计算、计算经济学、社会计算、计算生物学、计算农林学、社会计算、嵌入计算、企业计算、服务计算等等，结合这些问题来学习，这是非常重要的一个方面，一个非常重要的方面。 那么这张图呢？给我们反映了计算机专业导论课程的知识的构建次序，实际上它也是我们计算机科学与技术学科整个大的学科当中的知识的一个构建次序。 ★贯通的知识才是思维？ 那么怎么样学习呢（关于知识构建次序图的学习）？什么是思维呢？我们说贯通的知识才是思维。 我们说这张图——具体的细节内容，我们将在第二节当中给大家介绍，我们这里先不去细化的理解它。 实际上这张图反映的是一种思维，我们说零和一的思维。 ◇这张图为我们揭示了什么？ 那么我们看这张图，它为我们揭示的是什么呢？揭示的是：由社会/自然现象→☞逻辑→☞二进制→☞我们说电路，再到集成电路，最后到计算机，也就是说揭示了如何由社会/自然现象、社会自然问题，最后到用计算机求解的整个的这样一个思维。所以体现出来，我们说就是语义符号化→☞符号计算法→☞计算0（和）1化→☞0（和）1自动化→☞分层构造化和构造集成化，那么具体内容我们后面去学习 …… ◇从图的揭示里强调几点 一个就是怎么样学习？我们说通过这张图，我们可以描述如何来学习 表层意义-深层意义-集成意义 第一个我们学习它的表层意义，比如说我们这张图的左上角它是一个易经，用易经来表示的抽象，我们说这里面表层意义就是「什么是易经？」这个你要理解，易经的几个概念我们要理解。 但是我们说这个易经并不是我们这门课要求的内容，实际上我们要通过这种易经，我们要能理解它这种深层的含义，这些深层含义的理解才是最关键的。比如说我们要通过这个易经，实际上反映的是一种符号化、抽象化、计算化，它反映的是符号、组合来表示一种计算，所以这种深层含义是很重要的。 另一方面就是将易经这张小图，放到这张大图里面，它所反映的一种集成的意义。而这种集成意义对大家来讲很重要，实际上深层意义和集成意义的理解对我们这门课很重要，也是难点所在，因为我们说表层意义的理解很容易，但是深层意义、集成意义是需要我们不断的悟的！不断的悟的！这是一个很重要的问题。 ◇知识的贯通？思维？？ 那么通过这张图我们可以看到什么是思维？在我们这里来讲，我们把贯通的知识称为叫做思维，因为我们说若干年以后，在这里面的细节内容我们可能早已忘掉了，但是我们由社会/自然现象→☞逻辑→☞二进制→☞电路→☞集成电路→☞计算机这样的一个思维，这样一个过程我们却是忘不了的，而我们说几十年以后、几年以后、几十年以后忘不了的东西，实际上对于我们来说，这才是一个思维，所以我们说知识的贯通就是思维，我们要学习如何贯通这种知识。 ★知识vs思维vs能力？ 那么进一步来看思维和知识和能力之间的关系。 ◇思维 我们刚才说了，我们在大学阶段，那么贯通知识是一个很重要的方面，这种贯通可能在我们还不具有很细致的知识的前提下，我们来学会贯通，这是一个很难的一件事情，但是我们是必须要做的，因为我们要抬头看路，不可能我们都走过去了以后我们再回头来看，所以只能在很多的细节不清楚的情况下我们来看，所以我们要学习思维。思维重点是启发与理解，好奇、思考、联想、贯通，所以我们说大学的第一门课程，我们说应该学习计算思维，学习计算思维，这也是我们这门课的一个特点，也是我们这门课的一个目标。 ◇知识/技能 那么在有了一定的思维的前提下、基础上，那么我们可以不断的学习知识和技能，比如说：我们要学习计算机语言程序设计、数学建模、非数学建模、数据库，而这些方面的知识和技能，那么更多的是在我们计算思维的指导下，不断地这种练习、练习、再练习才能掌握的！才能掌握的！换句话说，像这样一些内容，它不是说简简单单地学，而是要更多地练。所以知识/技能是通过练习，训练与掌握的 ◇能力 那么进一步呢，实际上我们在后期会有一些这种视野拓展、知识拓展的这样一些课程，那么当我们能够在这些知识拓展，在这些技能训练基础上，我们可以把这种思维转化成能力！啊转化成能力，所以在这里面来讲，这是思维、知识/技能和能力之间的关系。 ◇打个比方理解这三个点的关系知识点-穴位 我们给大家打一个比方，比如说：我们人身体上，我们有若干个穴位，这一个一个穴位，就是一个知识点。一个穴位就是一个知识点。 思维-脉络 而若干的穴位，它们之间的这种脉络，我们称为叫做思维，称为叫做思维，所以我们把贯通的脉络称为叫做思维。 实践-锻炼，使脉络贯通 但是真正能够贯通这样一个脉络，使这些气息在这些穴位之间来回这种游走，我们说这个时候，这是需要不断的锻炼的，那么这就需要实践。那么通过不断的练习，使得气息在这里面不断地这种游走。 能力-内功（贯通的脉络） 这样的话，我们说当你经过日积月累这种训练以后，你可以将这种思维转换成能力，所以我们说将这种能力，我们把它称为叫做内功，实际上是贯通的脉络，贯通的脉络。那么思维呢？就是一些穴位链，也就是这些穴位要贯通起来，那么我们要知道，但是我们知道，但能不能够做到呢？能够做到的话，就必须要经过不断地练习。 ◇我们这门课的学习 所以我们把这样一种内容——我们这门课的学习，我们可以理解为打通知识脉络，融贯各门课程，内功强化基础，外功灵活应变。那么所谓的外功就是我们不断接触到的一些软件、硬件的应用，所谓的外功就是我们要学习的一种计算机语言及其程序设计，那么像这样一些内容，在我们有了内功的基础上，那么它才能更好地发挥出来！更好地发挥出来。 ★总结 通过思维贯通（连接）那些游离的知识点，这是点到线的过程，而这根线就是思维了；通过不断地实践使思维贯通，这是线到面的过程，这个面就是能力了，这个面也叫做内功。 有了内功，那些外功诸如软硬件的应用、计算机语言及其程序设计，才能更好地发挥出来！ 多看知识构建次序图…… 之前你一直说「无法将零碎的知识点组织起来」，那么现在我想你应该知道原因了吧！即缺乏一种思维，而且即便有了这样一种思维，也还得要不断地练习，才能把这些知识点转化成一种能力，有了这样一种能力，那么知识学习的速度跟不上计算学科知识膨胀的速度的矛盾，就迎刃而解了……]]></content>
      <categories>
        <category>计算机专业导论</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专业导论这门课学什么？]]></title>
    <url>%2F2018%2F06%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%AF%BC%E8%AE%BA%E8%BF%99%E9%97%A8%E8%AF%BE%E5%AD%A6%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[即便用了讯飞听见，依旧很吃力。一旦免费的2小时录音转文字用完了，这就意味着是时候说分手了！不管怎样，还是得要理清这一小节讲解的内容逻辑…… ★课程是如何组织的？ ★为什么要学习计算机？ 大家都知道我们学习计算机是希望用计算机来求解社会自然问题， 换句话说，就是通过计算手段求解社会自然问题 对于我来说，就是为了防止脑子生锈…… ★什么是计算？而数学上的计算和计算学科的计算又有什么差别？ 首先看看人计算： 人计算的是数学学科要研究的内容，它主要为我们提供了求解各种问题的一些计算方法，它可以让我们利用这些方法获得计算结果。 而对于计算机学科来讲，那么主要研究的是让机器自动计算，因此机器自动计算是计算机科学要研究的问题。 点与面的关系…… ★怎样实现机器自动计算？ 这就要涉及到几个问题 了 ◇第一个：程序 第一个我们说涉及到程序，大家都知道计算机学科里面很重要的一个概念就是程序，就是要编写程序，因此我们这门课呢要求大家理解这个程序是如何对机器自动执行的，这里面就是一道程序和系统之间的关系。 ◇第二个：编译 那么第二来讲呢，我们说如何编写机器可以执行的程序呢？ 那么这个时候就涉及到计算机语言，以及如何将用计算机语言编写的程序，翻译成机器可以执行的程序。我们说这就是编译 ◇第三个：算法 第三个问题，要解决如何构造求解问题的算法。也就是说从问题到算法，到程序，我们说这些内容是属于机器自动计算的这样一个范畴。主要用于求解，主要用于理解这个计算系统如何构造。 ★进一步分析，让机器自动计算的时候，会面临啥问题？◇机器难以计算 如果这个计算量特别的大，那么机器在有限的时间内，比如说几秒钟，长一点几分钟几十分钟之内，那么求解不出来，甚至求解这个问题可能需要几年几十年，那这样的，我们说这属于机器难以计算。 ◇怎么办？机器说「难于计算」 实际上我们需要探讨哪些问题是可求解的问题，哪些问题是难求解的问题 难求解的问题 对于这些难求解的问题，我们如何降低这些计算量？那么这就涉及到计算和算法，也就是在这个里面的算法主要强调是降低计算量，因为我们按照标准的计算量，那么可能很难计算来在短时间内难以计算出来，那么这个时候我们说怎么样通过降低计算量构造一些算法，所以说算法的目标在降低计算量。 进一步来讲，怎样研究这样一些算法呢？ 可以借鉴自然界生物的一些规律，可以借鉴一些其它类型的这种计算系统，我们说可以去研究不同的算法，我们说机器自动计算和机器难于计算，这构成了计算机科学的研究内容。 ★机器——自动计算，和机器——难于计算这两个问题都被干掉了，下一步？◇计算和社会/自然的融合 如何针对具体的社会/自然问题如何计算？ 这是一个很重要的方面。 进一步考虑，计算如何与社会/自然深度融合？ 这是我们要解决的过程 所以我们这门课程，主要是从机器自动计算，要解决「程序与系统」「语言与编译」「问题到算法到程序」，那么进一步到「可求解、难求解」，接着讲「计算与算法」和「怎样研究算法」，然后我们说还要学习一些「怎样结合具体的社会自然问题，用计算学科的这种手段来进行求解」，这是我们这门课程内容的基本脉络。 所以我们说，这样的话，由「数学+计算机科学」，那么扩展到了计算科学 5min的视频，所蕴含的信息量……真得让人难受！！！没办法，谁叫你不能用自己的话重述这些内容…… ★对于计算（机）科学，我们要学什么？ 我们要学习一些计算思维，我们要学哪些计算思维呢？我通过这样一棵树来给大家反映一下，也就是这些思维是需要我们在这门课程当中要学习的，可能我们这里面列的一些思维大家还不能够完全理解，没有关系，我们在后面的课程当中，将深入的解释这里面的各个思维的一些内涵。 ◇这颗树信息量很大 ★解析这棵树◇树根 这棵树很重要的就是树根，而这个树根是整棵树的一个源头，即你想要理解整棵树上的思维，那么这个树根上的思维是必须要理解的。这里面就包括了「0和1的思维」、「程序的思维」、「递归的思维」，那么这几个思维对于理解程序是如何被计算机执行的，这是很关键的，所以我们把它称为叫做奠基性思维。 ◇树干 另外一方面，我们可以看这个树干。这个树干是衍生各个树枝的一个重要的部分，所以在这树上很重要。 那么对于我们计算机来讲，那么大家知道在这个树干上最主要的是体现了一些计算环境，计算环境的演化。 计算环境的演化 我们说从冯诺依曼计算机到个人计算环境到并行分布环境到云计算环境， 我们说从早期的计算机到现在的云计算机，这是一场反映了计算环境的这样一个演化，那么大家可能对什么是云？什么是并行分布？还不理解，这没有关系，但是我们要知道这是从早期的计算机过渡到现在的计算机。 我们在后面的内容中还会给大家进一步介绍。 ◇树枝 可以看到这棵树，每一个树枝都出现为两种颜色，那么也就是说在每一个树枝的研究过程当中都要涉及到两个方面的内容，一个就是要构造算法，一个就是要构造系统，那么算法有算法的思维，系统有系统的思维，算法的思维侧重于数学建模，而系统的思维侧重于非数学建模，那么这两种能力都是大家不可或缺的能力。 ◇树叶 进一步来看，我们说这每一个树枝上，即在树叶这个位置上，大家看到这里面都在计算，比如说计算金融学、计算统计学、计算经济学、计算化学、计算物理学、计算语言学、量子计算、光子计算、企业计算、智能计算、计算工程学、服务计算、社会计算、媒体计算等等。 那么这些分支学科都是计算机和社会/自然相互融合的所产生的一些新的学科，那么这些新的学科广义上来讲，我们可以把它称为叫做计算科学。 深入的看计算科学 我们深入来看这个计算科学，我们可以这么来看，从树叶到树干这个方向，我们说从外到内来看，这体现了一种抽象，这说明是将自然现象的这种面向计算的表达，和推演，这样一种思维我们要理解，所以它的本质就是抽象。 那么另外一个从树干到树叶，它所体现的是计算求解的自然化，也就体现了自动化的含义，换句话说从树干到树叶，自动化程度越来越高，换句话说用社会/自然所接受的形式体现计算及结果，那么这个程度也越来越高。所以我们说这个计算与社会/自然相互融合的一个结果，它最本质的就是抽象和自动化。 有哪几种抽象自动化机制？ 典型的来讲，有以下这三种 第一种：语言和编译器 我们来看第一种就是语言和编译器。 语言和编译器解决了人和计算机交互的问题。人通过计算机语言编写程序，那么机器则根据这个计算机语言来理解这个程序，执行这个程序。 那么怎么样把这种语言编写的程序翻译成机器能够执行的程序呢？那么这个自动化的手段就是编译器，因此语言和编译器是很重要的抽象自动化机制。 第二种：协议和编解码器 另外一个就是协议和编解码器 。协议和编解码器解决了机器和机器之间、计算机和计算机之间、物体和物体之间的一个？？我们说交流沟通的这样一个机制。 那么大家都遵循相同的协议来处理问题，而执行这个协议的自动化的手段就是广义上的编码器、解码器、处理器、变换器等等。 第三种：模型和系统 那么另外一个更大层面的抽象与自动化机制就是模型和系统。那么对于模型来讲，那么它可以从业务模型融合到计算模型，而系统是执行这个模型的。 总结 我们在这里面大家看到这三种抽象自动化的这种机制也是很重要的。当然这个抽象自动化不仅仅是这三个方面，我们实际上整个这棵树的背后，它的最本质的东西，最核心的东西也是抽象与自动化，比如说像「0和1」「程序」「递归」这都是抽象和自动化的最直接的这样一个体现。 ◇划分这棵树，从内到外，有这么3个半圆 进一步把这棵树从内向外画分成三个半圆，大家看到我们要从树干向树叶方向划分 向右向发展 我们说向右向发展，大家可以看到这里面体现的是一种数据化的思维，也就是从数据库、数据挖掘、数据分析到现在这个大数据。那么我们知道大数据改变了人的很多观念。所以在这里面大家可看到数据化思维很重要。 从左边来看 那么我们往左边来看，实际上是由机器网络到现在这种信息网络到现在的网络化社会，我们说在这里面体现一种网络化的思维 这两个方向说明了什么？ 这说明了什么呢？也就是说对于这个树干上的每一个分支，我们都可以从内向外去延伸，我们都可以看到它有数据化的思维，它可以有网络化的思维。 所以现在社会/自然和计算的融合，一方面是强化了数据化思维，一方面是强化了网络化思维。所以我们在这里面大家可要对这个思维要有所理解。 那么可能对这里面的一些概念我们还不是很明白，可这没有关系，我们在后续的课程当中要对这些内容要做一些更细致的讲解，大家也不仅仅从我们这门课程当中，学习这些术语，学习这些概念，而且在其它课程当中都会深化对这些概念的理解。 ★回到计算科学 所以我们说我们计算机科学、计算机科学与技术从早期的计算机衍生出来，发展出来，我们现在到了计算机科学，那么进一步的发展和社会/自然的相互容许相互融合，就形成了计算科学。所以我们说这些计算思维是我们在课程当中要深入理解和学习的，我们希望大家在后续的课程学习当中对这些内容有深入的理解。 ★总结 深入的理解就是有这么两个字——那么。重要的事情说三遍，那么，那么，那么…… 这棵树告诉我们要学习哪些计算思维 关于这颗树的理解逻辑：树根→☞树干→☞树枝→☞树叶→☞抽象自动化→☞数据化网络化→☞计算科学 计算机科学与社会/自然相互容许相互融合就形成了计算科学？ ★Q&amp;A 计算机科学与软件工程的区别？ 参考：“计算机科学”与“软件工程”有什么区别？哪个专业更适合你？ 这两个专业的概述： 计算机科学主要从理论和数学的角度研究计算机如何工作。 如果你喜欢数学，逻辑学，或者你想进入CS的某个专业领域，例如人工智能，机器学习，计算机安全或图形，你应该选择计算机科学。 软件工程研究如何构建软件系统，包括诸如项目管理，质量保证和软件测试等。 如果您对实际操作方法更感兴趣，并且想要了解软件构建和维护的整个生命周期，应该选择软件工程。 计算机科学和软件工程都是学习编程和计算机科学的基础知识，因此您成为软件开发员，可以任选其一 学科与科学的区别？ 参考：说明文:科学与学科的不同 科学是符合客观规律的系统的思想理论体系，而人要了解自然或社会，就必须了解的详细，这就有了分门别类的认识和研究，而每一类，就成为了学科。 学科和科学的分别，恰恰仅仅在于前者不一定是符合客观规律的理论体系，后者则是符合客观规律的理论体系 偶遇的知识分类 来自这儿：人文学科和社会科学有什么区别？分别包括哪些学科？ - 四四四毛的回答 - 知乎 https://www.zhihu.com/question/22488479/answer/33909381 传送门：学科列表 自然属性和社会属性？什么鬼？？ 参考：自然属性和社会属性各是什么意思！ 自然属性：就是某一事物本身就有的性质！ 比如人：人的自然属性是指人的肉体存在及其特性。 比如商品：商品的使用价值是它的自然属性 社会属性：指这一事物处在某一事物中所具有的性质。 比如人：它的社会属性是指在社会实践活动的基础上人与人之间发生的各种关系。 比如商品：它的社会属性是价值。]]></content>
      <categories>
        <category>计算机专业导论</category>
      </categories>
      <tags>
        <tag>计算思维之树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么学计算机、计算与计算思维？]]></title>
    <url>%2F2018%2F06%2F16%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E8%AE%A1%E7%AE%97%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这是第一篇内容，也许是最后一篇，无论怎样，想写就写呗！不想写就放弃，反正，就是想写点什么。以下内容，来自这门课 计算机专业导论 ，如果有以后的话，同样是来自这门课…… ★有这么一句话 高度决定视野、角度改变观念、尺度把握人生 这句话来自于央视的一句广告语，说实在的我是不理解的，如果强制理解一波的话，会是这样： 站得高看得远，以不同的角度看问题，会改变你目前这个角度的观念，而有原则，有取舍才能把握人生 我查找了一些关于这句话的解释： 如这篇：高度决定视野,角度改变观念,尺度把握人生 而战老师对这句话的阐述就很不一样了，如： 我们只有站得高才能看得远，而只有看得远才能看得真。 根据这句话衍生了以下内容，而这些内容大都是摘录战老师说的话： ★计算机是什么？ 就是我们的台式机、笔记本吗？ 我们说不仅仅是这些，它还包括控制各种设备的这种大脑系统、控制系统， 便于人们各种应用的互联网产品， 伴随我们生活的各种便携式产品等等，那么这些都是计算机。 ★什么是计算机学科？而且计算机学科要学什么呢？ 是学修电脑？学一些软件和硬件的应用 ？ 我们说不是这样的， 我们应该学习 如何设计与人们息息相关的一些电子产品， 如何设计机械产品当中的自动控制系统， 如何通过计算改变人们的这种生活， 那么这些是我们要学习的，也就是说我们要学习计算思维。 我的内心独白： 什么是计算机学科？我想这很难定义吧！或者可以通过学习计算思维，就能大概知道计算机学科是什么了 ★这门课程主要讲什么？ 主要讲的就是计算思维 ★为什么说要站得高一些？◇站得低一些，看得近一些 那么我们很可能会认为：比如说程序设计很有用啊！ 马上，我们学完了以后，马上就可以编程序。爽歪歪的赶脚！ ◇站得高一些，看的远一些 实际上我们会感悟到会理解、会不会编程序？ 不是学学语言就可以的， 而是， 是否理解程序是如何被机器执行的？ 是否理解执行程序的这种环境， 是否有求解的这种计算思维，这才很重要。 这就是为什么你要站得高一些的因 ★为什么说角度改变观念？◇举个栗子 有一首词，这么说： 衣带渐宽终不悔，为伊消得人憔悴。 我们说这首词， 一般人来看是沉迷于爱情不能自拔， 而有些人则认为是境界不高， 可是我们换一个角度来看， 如果把这个「伊」当做一种事业， 那么他沉迷于事业不能自拔，那我们说这个境界是很高的。 这就是我们所谓的换角度来看问题了 专注吗？我想我应该要学习一下冥想才行…… ◇是思维有用？还是一些技术有用？ 从另外一个角度，我们来看思维有没有用？ 是思维有用，还是一些技术有用呢？ 思维，我们说有些人认为「不能马上转化为说我用计算机能做出什么」这样一种能力。 那么换个角度，一些软件你不讲我就不会吗？ 不是这样的，那么一些游戏软件没有人跟你讲，可你怎么会玩呢？ 是吧？还有一些软件给你讲了，可是你会用吗？ 软件不会用的根本原因在哪里呢？ 应该说是这个软件所体现出一种计算思维 ★为什么说尺度把握人生 ？ 这说明我们要不断的学习，不断的训练，不断的这种提高，由量变才能到质变 强制理解一波：对还是错都不重要 这里的尺度象征着你目前刻画的尺子，随着你的能力提高，它能丈量的东西也就越来越多了，即所谓的学一点就能多量1mm，而不是你的尺子只能量这么一点东西，你的知识量只能理解这么一点东西。 然后这把尺子就变质了，不单只是能够丈量实物，还能丈量抽象的事物…… ★题外话，这一讲的逻辑 为什么要学？ 怎样学？ 和学什么？ ★为什么要学计算机科学与技术？ 由图可见： 这张图是美国一个调查机构，那么所调查的2008-2018年期间的各个学科的人才需求和毕业生的供给情况 。 从这个图中大家可以看到， 我们说计算学科它的毕业生远远满足不了它这种工作的这种需求， 这说明计算学科的人才是非常受欢迎的。 那么从另外一个角度来讲， 计算学科人才的这种工资水平那么也是非常高的。 但你能不能拿到这样的一个高工资的这种职业， 我们说这取决于你对基础学科的理解、理解的深度，你学习的好与坏。 ★为什么要学本门课程？ 从另外一个角度，我们再来看为什么要学本门课程？ ◇计算机的发展概述 计算机从上个世纪40年代提出以来，发展到今天知识已经膨胀了很多 那么从早期我们只需要学几门核心的课程，如计算机系统、计算机理论，到人工智能这几门核心的课程学好了以后，我们基本上就能满足计算机的一种研究、开发、应用的需要 但是今天实际上我们说计算机已经和社会生活融入了，而且融入的很深了。 各个方面都需要计算机，而计算机也在向各个方面去发展。 ◇一张图告诉你计算机目前在朝哪些方面发展 这张图里面给我们列出的一些方向，而这些方向我们现在还不能够理解 但是我们先要知道它，我们也不去过深的解释 比如说：数据库、数据挖掘、机器人、机器学习、自然语言理解、计算生物学、 计算经济学、几何计算、算法图形学、人机交互、安全、网络、分布式系统、硬件、 服务计算等等 按照我们说这些内容来讲，这都构成了计算机科学与技术的这种核心的内容 ◇还要学习跨学科的知识 我们要学好计算机，还不能仅仅学计算机专业方面的知识， 可能我们还要学习一些跨学科的知识，比如说： 我要研究数据挖掘，可能我要学一些统计学方面的知识。 我要研究自然语言理解，我要学习语言学方面的知识， 我要研究计算生物学，可能我要学一些生物方面的知识，是吧？ 我要学硬件技术，我可要学一些电子工程方面的技术。 那么这就说明：要学的内容很多，我们是学不过来的。 ◇那么多东西是学不过来的，怎么办啊！两位名人告诉我们前卡梅基梅隆大学计算机系系主任周以真教授提出 ： 在大学阶段应该重要的是学习计算思维 前ACM主席也提出： 我们要在学习的过程当中，我们应该学习计算的伟大原理 那么，由此可得，这都说明我们要学习计算思维。 ★计算思维？什么鬼？？ 计算思维被人们称为和理论思维、实验思维并存的三大思维之一 ◇理论思维 理论思维是以数学学科为代表的， 它主要强调我们说的： 定义、性质、公理、定理及其证明。 那么这一套研究方法对于大家很重要 ◇实验思维 实验思维是以化学学科为代表的， 它通常强调要通过观察、实验，发现一种现象，对现象进行归纳、总结来进行研究。 ◇计算思维 我们说计算思维是以计算学科为代表的， 当前无论是理论思维、实验思维的研究，都需要通过计算手段来辅助支撑， 因此计算思维已成为和理论思维、实验思维并存的三大思维之一。 ★大家都说要创造性，那么创造性思维是怎么来的◇所谓的人才 从我们计算机学科的角度来讲， 我们的人才应该具有一种复合性的思维， 也就是说不仅仅有我们这种计算机学科的思维，还要能够和其它的学科能够相互的融合，形成这种复合性的思维， 只有这种复合性的思维在现在来讲，应该说才是一种创造性思维，而大学生应该培养一种创造性思维， 这一点很重要。 ◇如何建设我们这种创造性思维？ 我们在学习过程当中，应该不断地通过这种计算思维的学习，结合着其它学科的这种「那么相关」的思维体系。我们结合起来，共同建设我们这种创造性思维，为我们未来这种创造性奠定一个基础。 ★总结 我一直觉得「学习一门语言的语法后，然后按照特定的套路去模仿去copy他人的demo，偶尔做些简单的逻辑思考，组织自己的demo」这种方式去学习编程，有种被束缚的赶脚，而且很容易停滞不前，况且新东西层出不穷，吾生有涯而学无涯，这么学是很容易丧失对编程的热情的。我宁可每天花几个小时去学习我错过的基础知识，而不是每日都在学着这个东西怎么用，然后做点东西就完事，这是一种为了用而去学的学习方式。我知道，有很多东西是很类似的，按这种方式这样学下去的话，对自己的成长，不会有半点波纹…… 还是那句话，永远都不会变的——万丈高楼平地起，勿在浮沙筑高台 关于创造性思维，需要你融合三种思维，理论思维+实验思维+计算思维。这一点尤其的难…… 如果你想继续学习编程，那么计算思维很有可能是你前进的最大绊脚石 很多东西都很烧脑，所以不要忘记要按时作息、锻炼身体、饮食规律，还有最重要的是要有一颗淡定的心 很多东西都可以换个角度去思考，尤其是当你认为这东西让你很难受的的时候 不要一次做多件事，不要东想西想，先专注做好一件事，才去做下一件事，别搞得想个大忙人一样 你的世界观很有问题，你需要多出去走走，不然你会被自己的「为什么？」给弄得不知所措 不要什么都去学，毕竟这一生可不会很长…… 一切烦恼来自内心 ，愿自己试着去冥想，放空一切…… 不要一直学习下去，试着去找调剂品，比如吉他、唱歌，做一道很好吃的菜、去一次旅行…… 寻找一份爱情，不然偶尔的某个旋律、某个镜头、某个不知所以然的悲伤等等，会让你大哭一顿 三人行，必有我师，多请教，多提问，脸皮要搞厚一点，不然爱情也没了 有些价值观明知是错的，就得要舍弃，别习惯主义、经验主义 还有很多……可做到以上几点，我想这需要很久很久，至于多久？1天？1个月？半年？1年？十年？还是一辈子？]]></content>
      <categories>
        <category>计算机专业导论</category>
      </categories>
      <tags>
        <tag>计算思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是概念？]]></title>
    <url>%2F2018%2F06%2F12%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%A6%82%E5%BF%B5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子最近在学习CSS的知识，其中有关BFC的讲解，让我对「概念」二字的认识产生了疑问，比如：「任何事物都有其概念的吗？」「到底什么是概念呢？」「你能讲清楚这个事物是什么吗？」「有些东西是不是根本就讲不清楚的？」……我是不是功力不够，我一直都无法讲清楚一个东西是什么；我是不是功力不够，我一直都存在着顾此失彼的问题。我很难理解几个东西组合起来后所产生的某个效果，这似乎是必然的，可又存在着偶然，而它们之间的联系是怎样的呢？我发现无法继续深入下去了，这就像是到了一个瓶颈一样，而这种状态已经持续很久了。我无法熟视无睹，可又无可奈何！ 有么这么一句话： I know it when I see it 这是联邦最高法院大法官斯图尔特说的，这是关于「什么是色情？」的回答，翻译过来就是： 我不知道什么是色情，不过，我看了之后，就能知道 色情这个概念是说不清楚的！可是一旦你看到某个具体实例的是时候，你就知道它是不是色情了，你可以判断它是与不是，可却无法定义它是什么。这真得很尴尬啊！ ★思维的基本形式参考这个答案：思维的基本形式 概念、判断、推理是思维的基本形式。概念是基石，从概念出发，衍生出判断，而判断又衍生出了推理。按照「细胞是生物体基本的结构和功能单位 」的说法，概念就是细胞，我们的思维就是生物体，这体现了概念是极其重要的，而且是缺一不可的。如果你作为一名21世纪的有为青年，穿越到古代，我想你必定会被古代人当作是疯子。为什么？因为你的讲话很皮啊！ 没有概念，你的思维活动就很难继续进行下去了，所以逻辑学要求我们在思维过程中，力求做到概念明确、判断恰当、推理合乎逻辑。 一旦概念出了问题，就会产生连锁反应，如错误的判断和推理…… 概念有这么两个重要的逻辑特征：内涵和外延。注意，我需要注明的是任何概念 ◇什么是「内涵」与「外延」？参考这个：逻辑学中「外延」与「内涵」是什么意思？ 之前学过JAVA，所以从面向对象的思想上来说： 内涵就是类的定义，外延就是类的实例 有个答案很简洁： 1、简单说：S是P; 2、譬如，S–苏格拉底–即外延extension，单词前缀ex–涵义很多； 3、人–P–白皮肤，人-前者内涵-connotation后者内涵–白皮肤。 关于内涵增加外延是否一定会减小 ？ 反正一般都会减小 如： 「人」这个概念： 按照这个内涵来说： 有两只脚两只手会思考的哺乳动物 你会发现这并不能代表所有人，即存在个例 那么不去纠结人这个概念，而是改为添加人的内涵，如中国人、湖南人、长沙人等等…… 那么，人的外延就减少了啊！ ◇什么是本质属性？照搬：本质属性 本质属性是事物的有决定性意义的特有属性。即决定该事物之所以为该事物而不是别的事物的特有属性。与“非本质属性”相对。 客观事物千差万别，它们各自所具有的不同的性质、特征，都是由其各自所具有的不同的本质属性所决定的。 再次阐述： 任何事物都有许多的属性，在事物的诸多属性中，有些属性是某个或某类事物所特有的，决定该事物的本质，使某一事物之所以成为它自己的最低限度，并把这种事物与其他事物区别开来。这种最低限度所包含的性质就是事物的本质属性，它是事物本质的规定性。 举个例子： “能制造和使用生产工具的动物”是决定人之所以为人的特有属性，所以它就成为人的本质属性。要深刻地认识和把握事物、形成有关事物的科学概念，就必须揭示和把握事物的本质属性。 有了对「内涵」与「外延」、本质属性的认识后，我尝试着理解这句话： 内涵是概念所反映的对象的特有属性或本质属性，外延是概念所反映的一类对象，这些对象都具有概念的内涵所反映的属性 内涵是水果所反映的橘子的特有属性或本质属性，外延是水果所反映的一类对象，如这些橘子、苹果等等啊，都具有水果的特有属性或本质属性 ◇概念有哪些种类？搬照概念的种类有哪些？划分标准是什么 根据概念所指称的对象是否具有某种属性，划分为正概念和负概念。如，成年人与未成年人 根据一个概念外延的大小，即指称的对象的数量不同，划分为单独概念和普遍概念。比如，长江与河流。 根据概念所反映的对象是否为一个不可分割的集合体，划分为集合概念和非集合概念。比如，森林（集合）与树木（非集合）。 关于对集合概念和非集合概念的认识： 搬照概念的种类（集合概念与非集合概念） 集合概念是与非集合概念相对的，反映由同类分子有机构成的集合体的概念。如：“工人阶级”、“森林”。 这里的相对，我想其意思应该是指互相对立的两个“面”，就像是大和小是相对的，没有大就没有小；美与丑也是相对的，没有美就没有丑。我能否理解成「不是……就是……」，如「不是集合概念，就是非集合概念」，可是这世界存在一种叫「一般」的东西啊！你的胸大吗？一般。你的相貌如何？一般……这里的「相对」就有种随条件而变化的味道，如篮球和排球的比较，排球就是小的，而排球和乒乓球和相比，那就是排球大啊！随着参照物的不同，这个东西的属性也会发生变化啊！ 还有一点的就是对有机构成的理解：1+1&gt;2 在某一思维对象领域，思维对象可以有两种不同的存在方式 : 一种是同类分子有机结合构成的集合体，另一种是具有相同属性对象组成的类。 而对象集合体与对象类的根本区别是： 集合体的性质，构成集合体的个别对象不必然具有；对象类具有的性质，组成类的个别对象必然具有。 如何区分集合概念与非集合概念呢？ 这关键在于，在一个确定的语境中，一个确定的命题其所表达的性质是整个集体（或整体）才具有的，还是每一个（任意一个）个体都必然具有的。前者叫集合概念，后者叫非集合概念。 举个栗子： 清华大学学生来自五湖四海 。 这个命题中的“清华大学学生”就是集合概念，因为“来自五湖四海”不是每一个个体具有的属性，只有集体总和才具有。 清华大学的学生都是很优秀的。 在这个命题中，“清华大学学生”是非集合概念，因为“都是很优秀的”，其强调每一个分子都必然具有“优秀的”性质。即：对于任何一个x来说，只要是s，就具有p的属性。 从这两个栗子可以看出： 同一个概念在不同的语境中可以是集合概念，也可以是非集合概念。区分是集合还是非集合，其标准在于是否指向一个不可分割的整体。 所以，这一点恰恰体现了 集合概念是与非集合概念相对的 有这么一个常见的栗子，这个于我眼中似曾相识： 鲁讯的著作不是一天能读完的，《狂人日记》是鲁迅的著作，因此，《狂人日记》不是一天能读完的。 这个推理存在逻辑错误： 偷换概念 为什么？ 命题“鲁讯的著作不是一天能读完的”中，“不是一天能读完的”这一性质并不是每一本鲁迅的著作都具有的性质，只有所有鲁迅的著作加在一起的集体才具备这一性质，因此，这一命题中的“鲁迅的著作”这一概念为集合概念。把一个集体具有的性质看作每一个个体都必然具有，这种错误叫偷换概念。 ◇对概念的基本认识 概念有不同的种类，各种概念之间存在着不同的关系；概念是通过语词表达的，概念和语词既有密切的联系，又有本质的区别。逻辑学提供的关于概念的基本知识，是我们正确应用概念的必要条件。 ◇诡辩手法存在着这么一类人，他们叫诡辩论者，而他们在概念应用中的诡辩手法主要有： 玩弄语词游戏，利用歧义词、谐音词混淆概念；故意曲解概念的内涵和外延，以及主观地应用概念的灵活性，等等。 关于对诡辩论者的认识： 在宣传中论证一个命题或说明一个问题时，诡辩论者不去如实地、以有力的逻辑力量揭示事物的内在联系，而是从主观出发，以片面的、表面的、甚至不相干的一些现象制造虚假的联系、因果关系和主从关系，达到混淆是非、颠倒黑白的目的，为其荒谬的言论制造一种骗人的推理形式。 而所谓的诡辩论指的是「违背逻辑规律而做的一种似是而非的推理和论证」。 ★总结 我似乎又跑题了，在查找答案的过程中我迷失了方向 从思维的基本形式的角度来阐释了概念的重要性 任何概念都有两个重要的逻辑特征：内涵和外延 把找到的信息如何有机的结合起来，这是个问题 什么是概念？不知道，按照这篇文章的说法： 概念就是大脑按照一定的方式划分和组织各种意识现象而生成的认识对象。 这句话很不好理解，我想需要继续写一篇「再次认识什么是概念？」的博文 不过，我还是可以强制理解一波的： 简单理解一下，概念就是认识对象，如何认识？有机结合大脑的各种意识现象来认识。]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你该换个角度看球了]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BD%A0%E8%AF%A5%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%90%83%E4%BA%86%2F</url>
    <content type="text"><![CDATA[6月1号，儿童节！小学生库里的球队赢了 我知道这是裁判的锅，这并非是空穴来风，不管是对于火箭来说，还是骑士，总会有一些哨子在关键的时刻对勇士有利，无外乎打乱对方的节奏，比分胶着到最后时为勇士助力……也许裁判也要为勇士建立起王朝打call！况且你也应该知道，在全美，希望勇士输的人的占比远远大于不希望的 本场比赛詹姆斯出战48分钟，投篮32中19，三分7中3，贡献51分8板8助。 又是一个48分钟，而且对老詹能拿51分并不感冒，毕竟如果他真的想得分的话，是很少有人能防得住他的，可是51分确实是很少见了，本以为会一战封神的老詹，在比赛结果出来后，似乎并没有那么起眼了，对，这是一个看结果的时代！呵呵 没有人能忽视你们的努力，骑士队！对方球员不能，裁判不能，全世界的球迷也不能 「输」这个字眼，很有魔力，也许是跟你这辈子最亲近的一个字，之前我写了一篇文章是关于「绿军和骑士的第七场大战」的，这篇文章我是作为胜利者一方来写的，于是，我会带着有怜悯的味道来看待绿军的，而这次我作为输家，来看待比赛的结果，我是很难受的，如果有勇士球迷来怜悯我们家骑士的话，那么结果很有可能是「不需要」。「输赢」说真的，真是件很操蛋的事儿！ 输赢真的有那么重要吗？ 我想我需要去了解一下体育精神是什么？ 体育家精神是指一种追求公平竞争，对于队友和对手谦和有礼，遵守道德，待人真诚，无论输赢始终保持体面的态度。对于此，现代奥林匹克之父皮埃尔·德·顾拜旦曾说过：“最重要的不是输赢，而是参与”，这是对体育家精神的一个经典表述。 我们往往在乎的是输赢，毕竟这是最直观，也是最直接能够得到反馈的，我们都觉得自己很忙，忙到没有时间去了解一个人的过去，确实，这个世界就是如此的 敢问，这个世界存在没有输赢的游戏吗？ 传送门：有没有没有输赢的游戏？ 我的世界算是没有输赢，也没有目标，完全瞎玩 我觉得没有. 输赢的定义如果是”拥有一定的失败条件” 那么沙盒游戏依然会有. 没有输赢的不是游戏.是玩具. 游戏是一定规则下的行为 规则必须指定条件,不符合条件的就算不是输,也是失败. 广义的来说失败就是输. 所以不存在没有输赢的游戏. 但是存在非零和的游戏. 本来问题就是没有输赢的游戏。。 ps：沙盒游戏一种高自由度的游戏，游戏的规则，没有显得那么重要，或者说根本不重要 我们为何会在乎输赢？ 有人说： 不是孩子输不起，而是父母太想赢！ 是父母灌输给孩子的价值观 我从未了解过输赢的定义是什么？ 我只知道，赢了就是高兴一整天，而输了就是难受一整天。我几乎不可能因为「不要在乎结果」这句金句，而让泪水止住，鸡汤没有让我好受些，我也不会为自己熬鸡汤，只有时间方能抹去，可有些输也许一辈子都会牢记于心，久久不能抹去，它们似乎在你的内心扎根了，直到你的心脏停止了，你才会一笑解千愁，原来不过如此…… 我看到了一篇文章，这是对输赢最好的阐述： 传送门：输赢真的不重要？重要的是什么？ 其中的观点： 输的主要5点原因： 态度问题——《摔跤吧！爸爸》里面有一句台词:土地不会自己长出庄稼。只有踏实付出，认真对待，充分的准备，才能把握机会赢得比赛。 无目标——脑子里没有制定要赢的计划。甚至都没有赢的意识，又怎么能赢 没做到持之以恒 ——向达芬奇画蛋那样，坚持再坚持，就会靠近目标，实现梦想 .没有好的学习习惯 ——孩子们都很聪明，习惯会让他们拉开差距。一会抓耳，一会挠头等不良的学习习惯，会分散很多注意力，导致学习低效率。 没有做到学以致用 ——只有把学到的知识灵活地运用出来，理论结合实际，融汇贯通，反复练习，才能熟而生巧。 还真是这么一回事啊 对输赢的态度： 人生中考场处处在，输赢时时有，输赢虽重要，仍需理智的心态去面对。争取赢不骄，败不妥。分析输的原因，总结赢的经验，即看重了结果，也乐在了其中。 输赢相对，需理智对待。赢，是动力；输，检验出不足，也能让我们快速成长。 有输就会有赢，这世界难道就没有没有结果的东西吗？ 这让我想起了墨菲定律 传送门：如何理解「墨菲定律」？ 感谢自己的这个提问，让我减轻了心理负担 为什么？有一个答案，让我觉得很有触动： 很多乱七八糟的答案其实是在不负责任地传播负能量。根本就不理解墨菲定律的本质就在那里误导别人，自己是盲人，也要以盲带盲。这就是知乎的可恨之处。什么叫做坏事一定发生？不谈前提就说一定就是耍流氓。没有前提条件，你想让坏事发生也发生不了。而让墨菲定律成立的前提有两个。一个是大于零的概率。另一个是时间够长。（换句话说是样本够大。）假如少了这两个中的任何一个前提，墨菲定律就不可能实现。举一个例子，一个人一生中只要不是一直关在家里不出去，那么他就有大于零的概率会出现车祸。按照某些人不负责任的解释，那就会给人留下因为会发生车祸，所以一定发生车祸的错误印象。可这真是墨菲定律吗？还是这些人自以为是的墨菲定律呢？话说回来，为什么全世界六十亿人，真正发生车祸的人只有很少一部分呢，为什么墨菲定律在是否发生车祸上对于大多数人来说都不管用呢，对于个人来说，那是因为没满足时间够长这个前提，假如他活个八百岁，八千岁，把万分之一的车祸概率提升到了千分之一，百分之一，自然就很容易发生车祸了。而他要活到八万岁，才能让这概率接近必然实现。可是谁能活那么长，普通人只能活到八十岁，万分之一的概率有多小知道吗，很多人一生中连一百块钱的彩票都没中过，所以对车祸过于恐惧几乎可以说是不必要。只要过马路当心些就好了，假如有些不善于思考的人，看了你们这些乱七八糟的答案，以为坏事一定会发生，那么车祸一定会发生，那就是让这些人背上了不必要的心理负担。所以对于知乎我也想提出一个墨菲定律。那就是由于知乎上不负责任的答案那么多，而又有那么多不爱思考的人，那么，只要使用知乎时间够长，就必定会严重影响这些人的生活质量。因为认知决定着幸福度，知乎上那么多错误的消极的内容，自然有远远大于零的概率让很多人的三观发生扭曲。 墨菲定律成立的两个前提：大于0的概念和时间足够长 我想你一定有这样的想法： 随着生活的进行，被记住的糟心的事情越来越多，顺利的事情统统被忘掉。 所以当你回忆起来，记起来的都是糟心的事情，都是那些不巧的不幸的事情。 所以你下结论，坏事总是会发生。 其实只是坏事总是会被记住。 而在日常生活中，有一些事情需要你重复不停每天做的，一旦次数增多，那么变坏的概率就会得相当大了。 因此，你记住了那些事情变坏的瞬间，你称之为墨菲定律。 ★总结 没有绝对的输赢，只有你怎么看待输赢，你看到输的原因，那就是赢了 善于分辨他人的价值观，即便大多数人都是这样的认为，你也有保持理性，因为真理往往存在少数人手里 你又跑题了，你的题目是「你该换个角度看球了」，所以去找输球的原因，总结赢球的经验，而不是继续抱怨、不服，该打扫这些辣鸡了，至于那些无形的手？你那么喜欢赢就给你赢呗！我不在乎…… 那些让你难以接受的东西发生了，愿你还能勇往直前，直面人生。鸡汤虽好，可仍需自己熬鸡汤，毕竟是不一样的配方、不一样的味道，不然的话，那你很有可能会喝不惯 想的太多？忘记墨菲定律了吗？一直想太多的话，脑子废掉的概率也会增加…… ★参考资料 体育运动 什么是沙盒游戏？有哪些名作？ 孩子论对错，大人论输赢。既然如此为何恋爱时依然注重对方人品？教育孩子依然注重品格？ 孩子为什么会这样在乎输赢]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack和call stack]]></title>
    <url>%2F2018%2F05%2F30%2Fstack%E5%92%8Ccall-stack%2F</url>
    <content type="text"><![CDATA[★引子为什么arguments[0]能拿到事件参数e？ 123btn.onclick = function() &#123; console.log(arguments[0])&#125; 针对这个问题，开始了一段搜索旅行，这段旅行中你会遇到很多个疑问，当然这会加深你对JavaScript的认识…… ★第一段旅行——JavaScript 浏览器事件◇JavaScript、浏览器、事件之间的关系未完待续……]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷路]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[★迷路？笑话 如果发现自己确实迷路了，一定牢记国内外通用的STOP原则，即stay、think、observe、plan，意思分别是待在原地、思考、观察、计划，进行自救。 请记住STOP这个原则，不然你这个路痴，怕是要如崔健的「假行僧」里的歌词一样： 我要从南走到北, 我还要从白走到黑. 我要人们都看到我, 却不知我是谁. 假如你看我有点累, 就请你给我倒碗水. 所以，再说一次，请记住STOP原则——待在原地，打量一下周边，思考应对之策，按计划行事 你能不能抵达目的地，送你8个字： 谋事在人，成事在天 大概的意思是说： 自己已经尽力而为，至于能否达到目的，那就要看时运如何了 也许有时候你不得不信，冥冥之中，有很多事也许是早就安排好的，不过这应该是你该忧虑的吗？ 不去做，未免太无聊了吧！至少多了许多花样 害怕努力了注定得不到想要的结果？ 这是你该忧虑的吗？ 吃饭是为了什么？不吃饭就会GG啊！ 努力是为了什么？为了遇见更好的自己 这不就对了吗？ 结果固然让人欣喜，但你所踩过的坑，都会成为你成长的养分 所以，不要说看到希望了，才去坚持、努力，而是努力了，坚持了，才会看到希望 就如16赛季的骑士由1:3逆转了73胜的勇士，1:3的结果，已经看不到希望了，所以第5场直接放弃吗？不，他们并没有放弃，而是再努力一点，最后逆转夺冠 不要把结果看的比过程重要，你只需要把这次过程给你带来的养分吸收掉就可以了，就这样升级打怪，至于到了最后会不会有惊喜？谁知道呢？毕竟这可不是你此刻该关心的事……]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不能再要求你做的更多]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%8D%E8%83%BD%E5%86%8D%E8%A6%81%E6%B1%82%E4%BD%A0%E5%81%9A%E7%9A%84%E6%9B%B4%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[今天是抢七。对，这是东部的抢七…… 时间的指针拨回到第6场，骑士主场对绿军的比赛。首节，勒夫与塔图姆相撞，疑因脑震荡被迫离场，我已经记不清这是他几次脑震荡了。对，我黑了勒夫，哈哈！ 勒夫下去了，这对绿军是个好机会吗？非也，勒夫意料之外的下场，可以说打乱了绿军计划，而鬼才泰伦卢也一脸懵逼，歪打正着，为抢七的胜利埋下了伏笔…… 比赛就这么进行中，打得很胶着 ，直到末节的1min左右，詹姆斯的2记不可思议的3分，才带走了比赛。 詹姆斯全场打了46min，只有两次休息时间，一次是第三节左后1min，一次是末节最后1min……你不能要求他做的更多了，全场拿下46分，这是他职业生涯生死战的最高分。 赛后，绿军少帅史蒂文斯表示「已经没有赞美之言表示对詹姆斯的称赞了」，对，确实如此，老詹做的足够多了。骑士能赢，全凭自己的一口气吊着，当然也不能忽视其它球员作出的努力，这是一场属于大家的胜利。老詹的态度感染着队友，我想「队友们不做出点行动，怕是对不起老詹哦！」 有时，我在想「老詹你的力量总是无穷无尽，总是会给我们带来惊喜，你一直在进步，即便来到了33岁，依旧是联盟最强的小前锋……你对比赛的态度，对比赛的热情，对对手的尊重，无时无刻都在感染着我。可是你已经33岁了啊，这么努力到底是为了什么？该有的荣誉都有了，还在追求什么呢？」 其实，答案我早就有了。只是，还缺少根稻草…… 对了，绿军少帅史蒂文斯赛后还有一句话让我留下了深刻影响，他是这么说的： 如果你不能在比赛中享受乐趣，你为何还要这样做？那就是我看待这场比赛的方式，那也是他们（指凯尔特人球员）看待这场比赛的方式。 这是比赛应有的态度，同时这也是你人生该有的价值观。 我要装逼了，请准备好纸巾、桶，还有水…… 如果你不能在编程中享受乐趣，你为何还要继续敲demo？那就是我看待编程的方式，那也是大神们看待编程的方式 回到今天这场抢七。 我是不敢看的，真的。我得了一种「凡是看骑士比赛，骑士就会输」的病 好吧！我承认我的小心脏受不起折腾，怕这将是我人生中最后一次观看骑士的比赛，毕竟我没有速效救心丸。 比赛进行着，偶尔我会瞄一眼此刻的比分是多少，而脑子里一直回荡着「该死的，要输了，要输了……我……」，就这样反复着，循环着…… 来到比赛末节，我的心脏开始按照一定的加速度跳动着，由于没有吃早餐的缘故，我的胃有一种绞着的感觉，如比赛的胶着，而脑子开始有点晕了，也许是血糖低的缘故…… 我开始意识到，继续看下去，我真得会GG的。 我决定不继续看下去了。 脑子里一直回荡「骑士领先？还是绿军……天杀的，去你妈的，GG就GG」 我的天，骑士竟然领先了，就这样静静的看着，如老僧入定。我的双手开始颤抖麻木，掩盖不住我来紧张到极致的内心，加上没吃早餐的缘故，这种感觉尤其的强烈…… 我深深的吸了一口气，缓缓地吐了出来 因为结果已经出来了，「87-79」，这是一场防守极其残暴的比赛 我哭了，这是喜极而泣的结果，老詹真的做到了，在勒夫缺阵的情况下，打满48分钟，几乎打出三双，拿下了35分、15个篮板和9次助攻。 同时队友杰夫-格林19分，JR-史密斯12分，特里斯坦-汤普森10分9个篮板。而全队三分球35投9中。 我想到了「即便骑士赢了，最终还是亚军，毕竟绿军可没有一位可以在比赛最后时刻站出来的球员，他们缺少一位真正的球星，而西部就不用说了，不管是火箭的哈登、保罗（受伤，能上场未知数），还是老对手勇士的库里、杜兰特和汤普森，无疑是给骑士亚军的命运给宣告了」 我要喜极而悲吗？不，这不是我的价值观，此时此刻的我，正活在当下，而不应该是现在的我，去思考未来的我。高兴是存粹的高兴，而不是对未来的担忧。尽人事，听天命，所以我什么要「喜极而悲」呢？ 我找到了最后一根稻草，对，找到了 这是骑士和绿军融合起来的稻草，包含着信念、勇气、态度、友爱等等…… 每一滴汗水，只为享受比赛过程中的每一秒，你说为了什么？是为了结果吗？赢了就高兴不已，输了就悲伤不已吗？还是说一个输赢，就能看出你们的努力是不是白费的？ 对，体育似乎只看中结果，你没有赢只是因为你没有比他人更努力，可这样的措辞真得好吗？也许你会认为这可以激励他们更加的努力，但往往会给他们带来的是更多的压力，比赛没有输家，只有为享受与对手竞争的乐趣…… 不能在要求你做的更多了，老詹，同时也不能要求绿军们做的更多了。 这是一场没有输赢的比赛， 只有享受比赛的乐趣…… ps：感恩，让我最美好的青春遇见了你——老詹 对了，我是10年詹蜜 ​]]></content>
      <categories>
        <category>NBA</category>
      </categories>
      <tags>
        <tag>詹姆斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个无缝的轮播]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%A0%E7%BC%9D%E7%9A%84%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[★引子之前写了一个简单的轮播，然而这个轮播有一点不好的就是「滚动最后一张图片的时候，下一张不是直接到第一张图片，而是回退到第一张，才继续滚」，这一点很不好呀！如何做到「下一张是第一张呢？即所谓的无缝呢？」 ★基本的骨架12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="zh-Hans"&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;无缝的轮播&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" media="screen" href="style.css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="window"&gt; &lt;div class="images"&gt; &lt;img src="./1.png" alt="图片1" width="400" height="300"&gt; &lt;img src="./2.png" alt="图片2" width="400" height="300"&gt; &lt;img src="./3.png" alt="图片3" width="400" height="300"&gt; &lt;img src="./4.png" alt="图片4" width="400" height="300"&gt; &lt;img src="./5.png" alt="图片5" width="400" height="300"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要注意的是，文档的语言为「中文汉字」，我也不知道为啥选择这个，已经被弃用了的，搞不懂老师为啥选用这个，也许是为了兼容性吧！不管了，日后遇到坑再来填！ ★添加样式增加色彩123456789101112131415161718192021222324252627282930313233343536373839404142434445* &#123; margin: 0; padding: 0;&#125;* &#123; box-sizing: border-box;&#125;.window &#123; width: 400px; height: 300px; margin: 150px auto; overflow: hidden;&#125;.images &#123; /* display: flex; */ position: relative;&#125;.images&gt;img &#123; /* 父亲多宽儿子就多宽 */ width: 100%; /* 解决display-inblock的bug, 不写图片有缝隙*/ /* vertical-align: top; */ transition: all .3s; position: absolute; top: 0;&#125;.images&gt;img.current &#123; left: 0; transform: translateX(0); z-index: 1;&#125;.images&gt;img.leave &#123; transform: translateX(-100%); z-index: 1;&#125;.images&gt;img.enter &#123; transform: translateX(100%);&#125; 这里的 box-sizing、 transform需要留意，尤其是 transform这个「魔法师」，我一直认为它有着「动画」的标签，其实不然，它依旧是个静态属性（此时我还真不知道静态属性是个啥概念？），来个题外话： 在网页设计中，CSS被习惯性的理解为擅长表现静态样式，动态的元素必须借助于javascript才可以实现，而CSS3的出现改变了这一思维方式。CSS3除了增加革命性的创新功能外，还提供了对动画的支持，可以用来实现旋转、缩放、平移、扭曲和过渡效果等等，这些功能再一次证明了CSS3功能的强大和无限潜能 …… 关于定位，我一直认为「偏移量怎样也要写两个吧！如：top和left……」 关于 transition，我的理解是「元素发生变化时，需要过渡，即所谓的补间动画，这样一来不会显得生硬和突兀」 回到 transform这个「魔法师」，它的值，即「它所拥有的魔法」，是以函数的形式指定的，称作「功能符」……我不知如何理解这个知识点，是否可以「将就」着？如：这个魔法是能把元素水平平移多少个像素 ★切换状态的行为12345678910111213141516171819202122232425$('.images &gt; img:nth-child(1)').addClass('current')$('.images &gt; img:nth-child(2)').addClass('enter')$('.images &gt; img:nth-child(3)').addClass('enter')$('.images &gt; img:nth-child(4)').addClass('enter')$('.images &gt; img:nth-child(5)').addClass('enter')let n = 1setInterval(() =&gt; &#123; $(`.images &gt; img:nth-child($&#123;x(n)&#125;)`).removeClass('current').addClass('leave') .one('transitionend', (e) =&gt; &#123; $(e.currentTarget).removeClass('leave').addClass('enter') &#125;) $(`.images &gt; img:nth-child($&#123;x(n + 1)&#125;)`).removeClass('enter').addClass('current') n += 1&#125;, 3000)function x(n) &#123; if (n &gt; 5) &#123; n = n % 5 if (n === 0) &#123; n = 5 &#125; &#125; return n&#125; 有个叫「正交」的概念：参考 CSS 为什么这么难学？ 解释一下什么是正交。 你调过显示器的「亮度」、「色调」和「饱和度」吧。 「亮度」就是明暗程度，值越大，屏幕越亮。 「色调」就是颜色，你通过调色调，可以把红色调成绿色。 「饱和度」就是鲜艳程度，值越大越鲜艳。 「正交」就是，你调节这三者中的一个时，不影响其他两个效果。 你调节「亮度」的时候「色调」和「饱和度」不会变化。 你调节「色调」的时候「亮度」和「饱和度」不会变化。 你调节「饱和度」的时候「亮度」和「色调」不会变化。 「正交」看起来应该是理所当然的，对吧。 想象一下「不正交」的情况：你调节「亮度」的时候，「色调」和「饱和度」会跟着无规律的变化。如果是这样，你会调得想死，因为你很难调到你想要的效果。 而 CSS，就是「不正交」的。 我查阅了一下维基百科： 正交 正交是线性代数的概念，是垂直这一直观概念的推广 涉及到线性代数，我就不去深入了解了，因为我缺乏很多基础知识，理解起来不知猴年马月了…… 之所以说正交，是因为这段demo，就很好地体现了「正交」二字，这段demo，不要管CSS-demo，做了什么「背叛」它的事，如「不仅可以让图片水平平移移，还可以是垂直平移等等」，反正JavaScript-demo就不管你CSS-demo做了什么，反正「我」只是对元素切换状态而已，这一点很好地体现了「行为和样式的分离原则」 这里的 one()需要留意一下，很关键，它是指只监听一次事件后，就不监听了 ★优化JavaScript-demo12345678910111213141516171819202122232425262728293031323334353637383940414243let ninit()setInterval(() =&gt; &#123; makeLeave(getImage(n)) .one('transitionend', (e) =&gt; &#123; makeEnter($(e.currentTarget)) &#125;) makeCurrent(getImage(n + 1)) n += 1&#125;, 3000)// 以下就不用看了function getImage(n) &#123; return $(`.images &gt; img:nth-child($&#123;x(n)&#125;)`)&#125;function x(n) &#123; if (n &gt; 5) &#123; n = n % 5 if (n === 0) &#123; n = 5 &#125; &#125; // n = 1 2 3 return n&#125;function init() &#123; n = 1 $(`.images &gt; img:nth-child($&#123;n&#125;)`).addClass('current') .siblings().addClass('enter')&#125;function makeCurrent($node) &#123; return $node.removeClass('enter leave').addClass('current')&#125;function makeLeave($node) &#123; return $node.removeClass('enter current').addClass('leave')&#125;function makeEnter($node) &#123; return $node.removeClass('leave current').addClass('enter')&#125; 这段demo，让我很好理解了所谓的「链式操作」，不管是「移出类」还是「添加类」，其返回值依旧是当前节点 模板字符串的妙用，提供了简单的字符串插值功能，这是比 + 运算符更优雅的语法 这里体现了一个叫做「状态机」的概念，感觉有「高大尚」的影子存在，此时此刻，去理解「状态机」对我有遥远。目前的第一层认识：「当前状态，离开状态，进入状态」 ★总结 最终所呈现的demo，不是一蹴而就的，它会让你踩很多坑后，才会告诉你「这个实现应该长什么样子才比较易懂好理解」 此刻demo有繁琐的味道，此时要优化吗？不需要，把你的思路完整写出来后，才去优化。千万不要在思路还没搞清楚的时候，去优化demo…… 不要去纠结，这个方法是否是最好的，你能快点写demo，就快点写demo…… 今天老詹绝杀了，又是压哨。看来，「一物降一物」是跑不掉了……我在想「即便如此，今年冠军也绝非是骑士的……不过，结果真得很重要吗？享受每一场比赛，不是送给自己最大的礼物吗？」 ★参考资料 语种名称代码 网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？ HTML的lang标记 CSS3中动画属性transform、transition和animation CSS Transform / Transition / Animation 属性的区别 补间动画 JavaScript与有限状态机 状态机编程思想？ ★demo链接 无缝的轮播]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个简单的轮播]]></title>
    <url>%2F2018%2F05%2F01%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[★引子常见的网站多多少少都会有「轮播」的影子，为什么会有轮播呢？因为轮播图是焦点图的优先选择啊！不过，轮播图有时也会带来负面影响，可这是我目前该关心的事吗？ 不问所以然，实现一个简单的轮播…… ★用jQuery实现简单的轮播◇搞一个简单的骨架1234567891011121314151617181920&lt;!-- 搞4张图片 --&gt;&lt;div class="window"&gt; &lt;div class="images" id=images&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ5W5k8pZ4VXyZsIhTEXwtO-P3LmxCEJAlqG74onj4GGXTiMetE1A" alt="" width=284 height=177&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT0ANas9lOWusFru_yrCZ_xHovfxR5saXyrYW0kbKg3jCTe2tMeNQ" alt="" width=284 height=177&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTwXu4i_F3GwAt0P7KtTnSDqjpqaB6xl_v7WzydZY_81moLH2sv" alt="" width=284 height=177&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQoGY1n-T9rTSlUHY3XA6Brmv1mWJMHqV7RVD5hLWrMP0ImpS29-Q" alt="" width=284 height=177&gt; &lt;/div&gt;&lt;/div&gt;&lt;span id='buttons'&gt; &lt;span&gt;第1张&lt;/span&gt; &lt;span&gt;第2张&lt;/span&gt; &lt;span&gt;第3张&lt;/span&gt; &lt;span&gt;第4张&lt;/span&gt;&lt;/span&gt; 这里的「alt」我就不给上值了，反正只是测试…… 这里的4张图片，不是百度爬的，是谷歌爬的，百度的会防盗链，即此刻会有用，过段时间这图片链接就不能用了。 给图片加上宽高，这是图片的原始大小「284*177」，其它大小的图可通过Photoshop等工具调整，不过遵循的原则是「不要让图片变形了」。为什么要给定宽高属性呢？如果不给的话，就会触发重排，就像是「一个数组有几百个元素，插入一个元素，意味着，后面的元素会因此而平移一格」，这实在是很消耗CPU，你给定了宽高，则告知此位置的大小是「284*177」，这样一来等加载完图片的时候，就不会影响后面的元素了。好比是一矩形区域划分了10个格，用于停放单车，不多也不少……虽说要遵循「内容样式行为分离」的原则，可这里不需要这样做 ◇添加简单的皮肤1234567891011121314151617181920&lt;style&gt; .images &#123; display: flex; align-items: flex-start; transition: all 0.5s; &#125; .images&gt;img &#123; vertical-align: top; &#125; .window &#123; width: 284px; overflow: hidden; &#125; .red &#123; color: red; &#125;&lt;/style&gt; 这里用到了flex布局，相较于浮动布局，明显少了许多代码，毕竟若用浮动的话，还需要对父元素清除浮动呢 ◇给上行为1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt; // 拿到数据结构，伪数组 var allButtons = $('#buttons &gt; span') // 遍历这个家伙，为其旗下的每个元素都绑定一个点击事件 for (let i = 0; i &lt; allButtons.length; i++) &#123; $(allButtons[i]).on('click', function (x) &#123; // 拿到用户点击的那个元素，虽然target也能做到，但这是在没有事件委托的情况下 // index()得到当前元素排行老几，这是其父元素的范围 var index = $(x.currentTarget).index() console.log(index) // 动态生成平移的值 var p = index * -284 $('#images').css(&#123; transform: 'translate(' + p + 'px)' &#125;) // 解决点击事件与自动播放的冲突 n = index allButtons.eq(n) .addClass('red') .siblings('.red').removeClass('red') &#125;) &#125; // 实现自动播放，取余很关键 // eq()可以根据参数找出对应的DOM，并封装为jQuery对象 // trigger(),触发()中的事件参数，如点击事件 var n = 0; // 拿到按钮个数 var size = allButtons.length allButtons.eq(n % size).trigger('click') .addClass('red') .siblings('.red').removeClass('red') var timeId = setInterval(() =&gt; &#123; n += 1 allButtons.eq(n % size).trigger('click') .addClass('red') .siblings('.red').removeClass('red') &#125;, 1000) // 鼠标移进某个元素，就砸闹钟 $('.window').on('mouseenter', function () &#123; window.clearInterval(timeId) &#125;) // 鼠标移出，就添加闹钟 $('.window').on('mouseleave', function () &#123; timeId = setInterval(() =&gt; &#123; n += 1 allButtons.eq(n % size).trigger('click') .addClass('red') .siblings('.red').removeClass('red') &#125;, 3000) &#125;)&lt;/script&gt; 不是说好，样式行为分离吗？可为啥JavaScript-demo里存在样式？ 如果不这样做呢？设有100张图片，这意味着CSS-demo里需要写100次的「transform: translate(n)；」(n每次增加-284，从0开始)，然后你就简单的使用JavaScript-demo添加「class」,移除「class」。 原则并非绝对坚守，总有例外，利大于弊或弊大于利，请自行斟酌 违反原则，使用JavaScript-demo动态生成样式，这样就不用繁琐的切换状态、移除状态了啊 ★优化demo不优化CSS先，先把JavaScript-demo简单优化一下，如「找到重复的demo，就存在优化的可能」 1234567891011121314151617181920212223242526272829303132333435363738394041424344var allButtons = $('#buttons &gt; span')for (let i = 0; i &lt; allButtons.length; i++) &#123; $(allButtons[i]).on('click', function (x) &#123; var index = $(x.currentTarget).index() var p = index * -284 $('#images').css(&#123; transform: 'translate(' + p + 'px)' &#125;) n = index activeButton(allButtons.eq(n)) &#125;)&#125;var n = 0;var size = allButtons.lengthplaySlide(n % size)var timerId = setTimer()function playSlide(index) &#123; allButtons.eq(index).trigger('click')&#125;function setTimer() &#123; return setInterval(() =&gt; &#123; n += 1 playSlide(n % size) &#125;, 3000)&#125;function activeButton($button) &#123; $button .addClass('red') .siblings('.red').removeClass('red')&#125;$('.window').on('mouseenter', function () &#123; window.clearInterval(timerId)&#125;)$('.window').on('mouseleave', function () &#123; timerId = setTimer()&#125;) 这个demo依旧存在优化的可能，但这需要用到面向对象的知识 整个过程：拿到所有按钮，给所有按钮添加监听事件，按钮被点击了，为「#images」添加样式，同时会激活按钮（如红色）；接着是自动播放的功能，初始化第一个按钮为0，然后播放、设置闹钟循环播放。鼠标移入砸闹钟，鼠标移出，接着播放 这里的每个函数都不超过5行，甚是好懂，除了最上面的那个点击后触发的函数 ★总结 区分拿到的变量是DOM对象还是jQuery对象，为什么？这个API似乎不能用啊！ 有时看懂了他人的demo思路，可自己依旧不会写，依旧想不出来，其实这很正常。为什么？写demo就像是你学写作文一样，如老师布置作业要求写一篇散文，你看人家的散文能看懂，可是轮到自己写了，就GG了。想起高中时，作文都是40分，我就很郁闷了，及格分36分，就多了4分……不管写多少次依旧是40分，难道我不管敲多少次demo，demo水平依旧是原地踏步吗？其实自己根本没有想过如何改变自己的写作风格，依旧是最简单的套路，也许偶尔会有亮点，可这恰恰是某个时刻所谓的「灵感」，而这种「灵感」过去了，就过去了，它不会停留，更不会影响你的写作行为，因为连你也不知道「为什么就写出来了」，借用一句话说就是「我能怎么办？我也很绝望呀！」 所以你可以先尝试着模仿，如「看看朱自清的散文是怎么写的？其他人的散文又是怎么写的？」，这里学习一点，那里学习一点，逐渐地有了自己的风格，也许这需要一年、两年、三年…… 这个学习过程是集大家之所长的，为此才能形成自己的风格。要想自己写出一篇好的散文，做梦！你必须看很多人的散文才可以。同理，demo亦是如此，想要自己写出一个有思路的demo，同样是做梦！你必须有个积淀的过程，这个过程至少需要半年，如这个轮播，你至少需要看3个人是如何实现轮播的，然后你就会发现「咦！大家写轮播都是这么一个套路」，那么你就学会了，以后你写轮播同样根据这个套路来搞。 能否想出新的套路呢？就看你有没有这个灵感了……所以自己想不出怎样写是很正常的 jQuery的API——「trigger()」，自动触发事件，如其参数为 &#39;click&#39;，那么就不需要自己去点击元素才可以触发点击事件了，它会自动触发 需要重新学习一下CSS了 ★参考资料banner和焦点图的区别？ 轮播图这样的交互方式，真的有效吗？ 如何看待“沉浸式阅读/浸入式阅读”一词的流行？ ★demo链接 用jQuery实现简单的轮播]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let，更好的var？]]></title>
    <url>%2F2018%2F04%2F30%2Flet%EF%BC%8C%E6%9B%B4%E5%A5%BD%E7%9A%84var%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 我就喜欢，直接用元素的「id」作为DOM对象。这样操作极其方便，不用每次都要「document.get……」，这让我少写了许多个字符。难道这样用真得没有bug吗？ ★使绊子​ 你不是很喜欢，用「id」作为DOM对象吗？那好，这个元素的「id」值为「alert」，你猜打印的结果： 12345678910&lt;body&gt; &lt;div id="alert"&gt;Hello!World&lt;/div&gt; &lt;div id="x"&gt;我是「x」&lt;/div&gt; &lt;script&gt; var xHtml = x.textContent var alertHtml = alert.textContent console.log(xHtml) console.log(alertHtml) &lt;/script&gt;&lt;/body&gt; 不是显而易见吗？ 一个是『我是「x」』；一个是「Hello!World」； 你确定？有时候你会存在一些错误的认识，至今未尝发觉，你总以为别人都是这样做的，自己照着做总没错吧！而且也拿到了自己想要的结果，可是你有没有想过，这样用，也许存在「大前提」呢？ 那好吧！我就运行一下，看一下结果，证明小白我是正确的 结果： 12我是「x」undefined 此时此刻的你，大写的一脸懵逼……心里一连串的问号——问号三连 为什么？我不服，我不服……为什么「x」可以，而「alert」却不可以。明明就只有名字不同，难道连名字也是一种罪过吗？ 你打印一下「window」 1console.dir(window) 会发现window旗下并没有「x」这个key，却可以使用「x」 如可以这样： 12window.xwindow['x'] 对于「alert」来说，「alert」一直是全局属性，一直在window旗下 这意味着，如果你想要快捷地用「id」获取DOM对象的话，那么「id值」就不能与window旗下的全局属性冲突 可是window旗下并没有显示「x」这个key啊！却可以使用…… 为什么？没有探究的必要了，在我看来……有些东西不需要如此执着，就比如你这个，你可以假设很多答案，如：「控制台打印的东西有问题」……「window的第一层找不着就到其旗下的document里去找，然后找到」 如果非要找出个所以然，可以看一下stackoverflow的回答： Do DOM tree elements with ids become global variables? ★全局变量可耻，不能用​ 平时用x/y/……等避开了window的属性，才能通过「id值」直接拿到对应的DOM元素对象。可是如果没有避免呢？那该如何拿到这个DOM对象？ ◇无所畏惧，拿到DOM对象​ 随意起了一个名字，叫「alertDom」 12var alertDom = document.getElementById('alert')console.log(alertDom) 这是通过DOM提供的API拿到的对象，还以其它API也可以拿到，如： 12var alertDom1 = document.querySelector('#alert')console.log(alertDom1) ◇有所畏惧，alert()不能用了​ 我声明了一个变量叫「alert」 123var alert = document.getElementById('alert')console.log(alert)alert('你能看到我吗？') 结果报错了： alert is not a function 这个声明的变量是全局变量，它与window旗下的alert冲突了，说白了，就是覆盖了它 所以，你还是不要用全局变量好了，起个名字真费劲 ★全局变量？局部变量◇唯函数，方能成为局部变量​ 我们可以使用局部变量，以防和window的全局属性冲突了 123456function y() &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;y()console.log(window.alert) 可见全局的alert依旧是它，同时我们也得到了想要的alert值，即这个#alert元素 可是问题又来了，关于函数的名字，函数的名字也是全局变量啊！它也会存在冲突的可能性的 一个问题套着一个问题，如此反复…… ◇被忽视的函数名​ 函数名，作为全局变量的一份子，那么只好去掉了，改为匿名函数。可是如何调用匿名函数呢？难道还是这样子么 var fn = function(){}？这岂不是进入死循环了啊！ ★立即执行函数表达式（IIFE）◇立即执行函数​ 函数匿名了，可以立即执行吗？ 1234function() &#123; var alert = document.querySelector('#alert') console.log(alert)&#125; () 结果，报语法错误： Unexpected token ( 为什么？ 注意，这是前面的function()出错先 当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。 注意： var foo = function(){console.log(1)}()这样是可以立即调用的 如果是有名字的函数声明，然后立即调用呢 function foo(){ /* code */ }();//SyntaxError: Unexpected token 为什么？ 当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。 毕竟圆括号里并没有表达式，你直接敲下 ()也是会报语法错误的 那加个参数，可以吧 12345678//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：function foo()&#123;/* code */&#125;(1)//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:function foo()&#123;/* code */&#125;(1); 具体测试一下： 123456789101112131415161718var a = function foo(f)&#123; console.log(f);return f&#125;(1); //1console.log(a) //1var b = function foo(f)&#123; console.log(f)&#125;(1);console.log(b) //undefinedfunction foo()&#123; console.log(1)&#125;(2); //2function foo(f)&#123; console.log(f);console.log(3)&#125;(2); //2var k = function zzz(f)&#123;console.log(5);console.log(f);return 7&#125;(3)//5 3k //7var q = function qqq(f)&#123;console.log(5);console.log(f+1);return 7&#125;(3)//5 4q //7var t = function foo(f)&#123; console.log(f)&#125;(1);//1t //undefinedvar z = function(f)&#123;return f&#125;(5)z //5 ◇立即执行函数表达式​ 如何去掉匿名函数立即执行的语法错误？错误的本质在于，语法分析器看到了 function这个关键字，于是认为，你这个函数声明是没有名字的啊！于是就报错了 如何解决？ 将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。 所以可有： 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。 当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。 测试demo： 12345678(function () &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;)()(function () &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;()) 注意：括号放在哪也是有区别的，虽然结果一致 前者是「括号内的表达式代表函数表达式」 后者是「括号内的表达式代表函数立即调用表达式」 可见，函数名字没了，局部变量有了，而且还有立即调用 除了添加圆括号，还有别的方式吗？ 如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节 1234!function()&#123;/* code */&#125;();~function()&#123;/* code */&#125;();-function()&#123;/* code */&#125;();+function()&#123;/* code */&#125;(); ★使用let​ JavaScript很奇葩，为了使用局部变量，需要搞个函数，然后还要匿名，还要立即执行，立即执行报语法错误，于是，还得告诉浏览器我这个函数不是声明的 为此，JavaScript升级了 理论上，在JavaScript眼中，demo块是没有作用域的，但是升级了，就有作用域了。这个作用域的有无，是「let」和「var」决定的，即let眼中是有的，而var则无视 测试demo： 1234567891011// var的姿势：&#123; var alert = document.querySelector('#alert') console.log(alert)&#125;// 等价于：var alert&#123; alert = document.querySelector('#alert') console.log(alert)&#125; 这个alert还是会跑出去，成为一个全局变量，把window的alert给覆盖了，即「块」是包不住var的，于是就用了IIFE 而let是怎样的呢？ 123456789101112131415&#123; let alert = document.querySelector('#alert') console.log(alert)&#125;&#123; let a = 1&#125;// console.log(a)//a is not defined let b = 2&#123; let b = 3&#125;console.log(b)//2 ​ let的姿势：let也不会提升，在哪声明就在哪声明，不会变量提升；能认识这个let只有在这个块里面了，出了这个块就没人认识它了 ES6之前想要用局部变量，只好用立即执行函数表达式了，ES6出来后就，不需要了，毕竟有let这个神器 ★总结 若对元素设置id属性，值为「x」的话，那么可以通过window.x或者window[&#39;x&#39;]引用该元素，而不是使用DOM的API去获取该元素的DOM对象，而且这用的用法写入了html5规范 最好不要使用全局变量，毕竟很容易导致命名冲突，或者说是变量污染 要想使用好局部变量，用两种方式可以做到：一是立即执行函数表达式（IIFE）；二是使用ES6的语法let 一个这样的问题「直接拿元素id的值，并没有得到该元素的DOM对象」引发出了，好几个知识点，如「let和var」、「IIFE」、「function关键字」…… 若是放表达式的圆括号 ()，必须给上表达式，不然会报语法错误 ★参考资料 DOM概述 DOM对象 [译] JavaScript：立即执行函数表达式（IIFE） 直接使用id引用DOM元素 为什么要有js立即执行函数，存在的意义是什么？ JavaScript中var、let、const区别？ 函数声明和函数表达式的区别 ★demo链接 使用let的测试demo]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery不过如此？]]></title>
    <url>%2F2018%2F04%2F27%2FjQuery%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 你说我该如何学习jQuery？这个……先学着先吧！ ★你是几个意思◇我要封装一个函数​ 哦！你是要写个函数，对吧！ ◇我要一个命名空间​ 我想，你要为一个对象取一个名字，是不是，小白？如果是的话，叫「小花」不错，我表示强烈建议！就像是这样： 12var 小花 = &#123;&#125;小花.getWechat() 这个小花就是「命名空间」，旗下有个要自己实现的「得到小花微信号」的方法 如果要关联jQuery的话，那就这样： 123var dom = &#123;&#125;dom.getSibling(node) //得到节点的兄弟姐妹元素dom.addClass(node, &#123;a: true,b: false&#125;) //根据true/false,为节点添加类名 ​ 这里的dom同样是个命名空间，把封装好的函数，取其函数名，放在dom下面，那么，这个命名空间才有它存在的意义。其实说白了，命名空间就是个对象呗！这个对象，给了函数，生活的空间。所以你应该知道你要的是什么了吧！ ◇我需要一个API我觉得你是想要一个别人提供给你用的函数 ★我需要一些套路◇封装一个函数的正确姿势 随意起名 理清输入输出 改个好听的名字 ◇优化代码 如果出现类似的demo就存在优化的可能 ★jQuery是啥？我不知道◇自己封装两个函数得到节点item3的兄弟姐妹1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;ul&gt; &lt;li id="item1"&gt;选项1&lt;/li&gt; &lt;li id="item2"&gt;选项2&lt;/li&gt; &lt;li id="item3"&gt;选项3&lt;/li&gt; &lt;li id="item4"&gt;选项4&lt;/li&gt; &lt;li id="item5"&gt;选项5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function getSiblings(node) &#123; // 得到爸爸的所有的儿子，包括我 var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125; console.log(getSiblings(item3)) //&#123;0: li#item1, 1: li#item2, 2: li#item4, 3: li#item5, length: 4&#125; &lt;/script&gt;&lt;/body&gt; 给节点item3添加3个class 第一种方式：简单直接法 1234567// 添加类a、b、c//简单粗暴添加item3.classList.add('a')item3.classList.add('b')item3.classList.add('c')// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第二种方式：遍历添加法 1234567 //通过数组的方式 var classArray = ['a','b','c'] classArray.forEach(value =&gt; &#123; item3.classList.add(value) &#125;);// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第三种方式：集「添加和移除」于一身法 123456789101112131415 // 第3种更强大法： var classHash = &#123; 'a' : true, 'b' : false, 'c' : true &#125; for(let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;//&lt;li id="item3" class="a c"&gt;选项3&lt;/li&gt; 封装为函数 得到封装好的addClass： 1234567891011function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;&#125;addClass(item3, classHash) ◇优化addClass你是一个对象，想要调用一个方法，有两个姿势： 12obj.x()obj['x']() 所以可有： 12345678function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] var methodName = value ? 'add' : 'remove' node.classList[methodName](key) &#125;&#125;addClass(item3, classHash) ◇关联这两个API为什么需要关联?​ 这两个API都是在操作节点，一个是得到节点的兄弟姐妹；一个是为节点添加/移除class。而DOM的API都在document旗下。所以，依葫芦画瓢，我们同样也可以这样做。 如何关联？​ 在window旗下，命名一个叫小花的空间，然后在小花旗下，绑定这两个API 12345window.小花 = &#123;&#125;小花.getSiblings = getSiblings小花.addClass = addClass小花.getSiblings(item3)小花.addClass(item3, &#123; a: true, b: false, c: true &#125;) 为什么要用「小花」这个命名空间？ 这两个API谁写的？翠花写的，你确定？ 我写了几十个API，厉害吧！厉害，我每次要用你API的时候，都不知去哪儿找，就像是无招牌的店，听说有家店做的「藤条焖猪肉」特别好吃，可是在哪？ 为什么，我引入你写的API，我写的那些demo，出bug了，即把人家的全局变量给覆盖了。他人，一定发誓，我一定不会再用你写的API了，发誓三连…… 用了命名空间，就不会让声明式的函数写法，覆盖了他人的全局变量 ◇能不能把 node 放在前面比如说这样： 12node.getSiblings()node.addClass() 给出两种方法 第一种扩展 Node 接口​ 直接在 Node.prototype 上加函数，函数里this很是关键 12345678910111213141516171819202122Node.prototype.getSiblings = function () &#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;Node.prototype.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; this.classList.add(value) &#125;);&#125;item3.addClass(['a', 'b', 'c'])console.log(item3.getSiblings()) ​ 如果你不能理解这个this表示的是什么，可以这样： 12item3.addClass.call(item3,['a','b','c'])console.log(item3.getSiblings.call(item3)) call()的第一个参数，就是this。有些时候，demo虽然简洁了许多，可是理解起来也会难上几分，就如这个this一样，调用函数是方便了，可是却不好理解这个this，为啥指向调用者？ 请记住：this是call的第一个参数。 你他妈不明白this是因为你他妈不用call 第二种新的接口 BetterNode​ 从构造函数着手，Node的升级版，也叫「无侵入」 12345678910111213141516171819202122232425262728293031// Node的升级版：window.Node2 = function (node) &#123; return &#123; getSiblings: function () &#123; var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125;, addClass: function (classArray) &#123; classArray.forEach(value =&gt; &#123; node.classList.add(value) &#125;); &#125; &#125;&#125;var node2 = Node2(item3)console.log(node2.getSiblings())node2.addClass(['a', 'b', 'c'])console.dir(node2) ◇把 Node2 改个名字吧如这样： 123456789101112131415function jQuery(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById('x')let node2 =jQuery(node)node2.getSiblings()node2.addClass() ◇再给个缩写吧 alias1window.$ = jQuery ◇改进jQuery可传入选择器字符串12345678910111213window.jQuery = function (nodeOrSelector) &#123; let node // 特性检测 if(typeof nodeOrSelector === 'string') &#123; node = document.querySelector(nodeOrSelector) &#125; else &#123; node = nodeOrSelector &#125; return &#123; getSiblings: function () &#123;……&#125;, addClass: function (classArray) &#123;……&#125; &#125;&#125; ​ 这里用到了闭包，getSiblings和addClass都用到了node，那么它们就构成了一个闭包。不会说，你调用了这个jQuery函数完毕后，然后局部变量node存储的值就被释放掉了，由于这个局部变量跟返回值对象中的任意一个方法（或者说是函数）构成了闭包，这意味着就像是「全职猎人中酷拉比卡为了获取强大的力量，把它念能力实质化的锁链，跟自己的心脏绑在一起了」。如果释放掉，那么这个对象返回值，没有任何意义。「没有把念能力跟自己的心脏绑定在一起，就无法获得强大的力量，何谈去复仇旅团呢？」 就像是这样： 有时候，你问为什么局部变量没有被释放掉？回答说「闭包」啊！可是你依旧产生了质疑，如「函数调用栈不是入栈然后出栈吗？一念生一念死，为啥还会有记忆……」。其实你可以反问自己，「为啥调用函数的时候，会有调用栈的概念？」「为啥调用函数的时候，会有闭包的概念？」 他妈的说白了「概念不会凭空产生，它的存在总有它存在的意义，也许合理也许不合理，它总有一个理由，占着茅坑不搞事」，简而言之，就是「哥的世界你不懂，45度角仰望天空……」 如果你觉得复杂了，就是没有想清楚 如果你觉得闭包很复杂，那么我想你需要静静，不要去想它…… 操纵多个节点123456789101112131415161718192021222324252627282930window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123;&#125; //类型检测： if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) //伪数组 for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; nodes.getSiblings = function () &#123; &#125; nodes.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(value) &#125; &#125;) &#125; return nodes&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue']) 添加读写文本的API123456789101112131415161718nodes.text = function (text) &#123; if (text === undefined) &#123; var texts = [] for (let i = 0; i &lt; nodes.length; i++) &#123; texts.push(nodes[i].textContent) &#125; return texts &#125; else &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text &#125; &#125;&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue'])console.log(node2.text())node2.text('hi') ★jQuery初探◇调用jQuery这个函数jQuery是框架还是库？ Framework 帮你设计架构，而 library 帮你写代码。所以jQuery是库，不是框架。 初始化网页文档：要引入jQuery库 骨架： 123456789&lt;body&gt;&lt;ul&gt; &lt;li&gt;第1项数&lt;/li&gt; &lt;li&gt;第2项数&lt;/li&gt; &lt;li id='item3'&gt;第3项数&lt;/li&gt; &lt;li&gt;第4项数&lt;/li&gt; &lt;li&gt;第5项数&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 行为： 1234var nodes = jQuery('ul&gt;li')console.dir(nodes)var dd = jQuery()console.dir(dd) 结果： 可见这个jQuery库是把其API写到Object的原型里去的，这样一来就不用浪费资源了 ◇依旧可以使用DOM API 行为： 123var item3 = jQuery('#item3')console.dir(item3)item3[0].classList.add('blue') 只不过jQuery返回的是伪数组，所以你需要添加下标才可以，不过即便如此，我想你也不想用DOM API了吧！ ◇使用一些API 添加类、移除类：只是追加，不会覆盖掉原来的。移除后回到默认的蓝色 12item3.addClass('red')item3.removeClass('red') 链式操作：移除单前类，再添加，相当于是覆盖； 12item3.removeClass('blue').addClass('red')item3.removeClass('red') 移除红色后，没有回到蓝色 开关 添加2个button元素： 12&lt;button id='x'&gt;X&lt;/button&gt;&lt;button id='y'&gt;Y&lt;/button&gt; 鼠标点击按钮，就会切换item3的字体颜色： 123x.onclick = function() &#123; item3.toggleClass('yellow')&#125; 效果就像是，天黑开灯，睡觉关灯 为多个元素添加不同的类： 1234567var classes = ['blue','red','yellow','green','yellowgreen']y.onclick = function() &#123; nodes.addClass(function(index,currentClass) &#123; return classes[index] &#125;)&#125; ★jQuery不过如此？ jQuery 在兼容性方面做得很好，1.7 版本兼容到 IE 6 jQuery 还有动画、AJAX 等模块，不止 DOM 操作 jQuery 的功能更丰富 jQuery 使用了 prototype，我们没有使用，需要new的知识点 ★总结 在非迫不得的情况下，不需要自己写操作的页面API，毕竟你没有jQuery做的好，如兼容问题 如果要想操作页面，目前jQuery就能很好地满足，其它同类型的库没有必要引入 拿到一个节点或多个节点，然后调用API，我想这就是使用jQuery 如果是jQuery对象，那么接收的变量最好加上个\$，以免混淆 了普通的DOM对象，如 var $node = jQuery(&#39;ul&gt;li&#39;) 如何看jQuery文档？先记住一些常见的关于其API的单词，然后学会一个API如何使用后，根据需求去使用API。如果没有理解这个API关于中文的概述，那么试着看看它的英文 jQuery很不简单，但我们的使用是简单的，不然，也不会红了那么多年 ★参考资料jQuery 是库（library）还是框架(framework)? jQuery中.addClass()和.removeClass()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个jQuery的API]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjQuery%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[★引子​ 经常用jQuery库的API，真的好吗？为何自己不尝试着实现一个jQuery的API…… ★想要实现的功能 将当前文档中所有 div 的 class 都添加一个 red 将当前文档中所有 div 的 textContent都 变为 hi ★如何实现◇搞一个基本的测试骨架12345&lt;div&gt;我是1div&lt;/div&gt;&lt;div&gt;我是2div&lt;/div&gt;&lt;div&gt;我是3div&lt;/div&gt;&lt;div&gt;我是4div&lt;/div&gt;&lt;div&gt;我是5div&lt;/div&gt; ◇给上简单的皮肤12345&lt;style&gt; .red &#123; color: red; &#125;&lt;/style&gt; ◇按你想要的实现行为定义一个全局变量1window.jQuery = function (nodeOrSelector) &#123;&#125; 这个全局变量是个函数，形式参数可为「节点」或「选择器」，总而言之即是可传入节点对象或字符串。 之所以定义一个去全局变量，是为了有个命名空间，好让自己所写的API都归于jQuery旗下 开搞函数体声明一个局部变量1let nodes = &#123;&#125; 这个局部变量很重要，它是个伪数组 特性检测123456789101112if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length&#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125;&#125; 需要判断传入的参数是啥类型的？假如是字符串，注意这个字符串是选择器，根据选择器得到一个节点组成的伪数组，遍历它，把它扔到局部变量里去，这样就可以砍掉多余的NodeList接口 如果实参是Node的实例的话，那么nodes就只有一个元素了 添加「addClass」API12345nodes.addClass = function (className) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].classList.add(className) &#125;&#125; 添加「setText」API12345nodes.setText = function (text) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].textContent = text &#125;&#125; 返回值1return nodes ◇测试写的API12345window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 这里搞了个别名$ 「实现一个jQuery的API」的github源码 ★总结 实现两个API是否用到了闭包 我是用this访问的，所以没用到闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
