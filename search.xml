<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是概念？]]></title>
    <url>%2F2018%2F06%2F12%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%A6%82%E5%BF%B5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子最近在学习CSS的知识，其中有关BFC的讲解，让我对「概念」二字的认识产生了疑问，比如：「任何事物都有其概念的吗？」「到底什么是概念呢？」「你能讲清楚这个事物是什么吗？」「有些东西是不是根本就讲不清楚的？」……我是不是功力不够，我一直都无法讲清楚一个东西是什么；我是不是功力不够，我一直都存在着顾此失彼的问题。我很难理解几个东西组合起来后所产生的某个效果，这似乎是必然的，可又存在着偶然，而它们之间的联系是怎样的呢？我发现无法继续深入下去了，这就像是到了一个瓶颈一样，而这种状态已经持续很久了。我无法熟视无睹，可又无可奈何！ 有么这么一句话： I know it when I see it 这是联邦最高法院大法官斯图尔特说的，这是关于「什么是色情？」的回答，翻译过来就是： 我不知道什么是色情，不过，我看了之后，就能知道 色情这个概念是说不清楚的！可是一旦你看到某个具体实例的是时候，你就知道它是不是色情了，你可以判断它是与不是，可却无法定义它是什么。这真得很尴尬啊！ ★思维的基本形式参考这个答案：思维的基本形式 概念、判断、推理是思维的基本形式。概念是基石，从概念出发，衍生出判断，而判断又衍生出了推理。按照「细胞是生物体基本的结构和功能单位 」的说法，概念就是细胞，我们的思维就是生物体，这体现了概念是极其重要的，而且是缺一不可的。如果你作为一名21世纪的有为青年，穿越到古代，我想你必定会被古代人当作是疯子。为什么？因为你的讲话很皮啊！ 没有概念，你的思维活动就很难继续进行下去了，所以逻辑学要求我们在思维过程中，力求做到概念明确、判断恰当、推理合乎逻辑。 一旦概念出了问题，就会产生连锁反应，如错误的判断和推理…… 概念有这么两个重要的逻辑特征：内涵和外延。注意，我需要注明的是任何概念 ◇什么是「内涵」与「外延」？参考这个：逻辑学中「外延」与「内涵」是什么意思？ 之前学过JAVA，所以从面向对象的思想上来说： 内涵就是类的定义，外延就是类的实例 有个答案很简洁： 1、简单说：S是P; 2、譬如，S–苏格拉底–即外延extension，单词前缀ex–涵义很多； 3、人–P–白皮肤，人-前者内涵-connotation后者内涵–白皮肤。 关于内涵增加外延是否一定会减小 ？ 反正一般都会减小 如： 「人」这个概念： 按照这个内涵来说： 有两只脚两只手会思考的哺乳动物 你会发现这并不能代表所有人，即存在个例 那么不去纠结人这个概念，而是改为添加人的内涵，如中国人、湖南人、长沙人等等…… 那么，人的外延就减少了啊！ ◇什么是本质属性？照搬：本质属性 本质属性是事物的有决定性意义的特有属性。即决定该事物之所以为该事物而不是别的事物的特有属性。与“非本质属性”相对。 客观事物千差万别，它们各自所具有的不同的性质、特征，都是由其各自所具有的不同的本质属性所决定的。 再次阐述： 任何事物都有许多的属性，在事物的诸多属性中，有些属性是某个或某类事物所特有的，决定该事物的本质，使某一事物之所以成为它自己的最低限度，并把这种事物与其他事物区别开来。这种最低限度所包含的性质就是事物的本质属性，它是事物本质的规定性。 举个例子： “能制造和使用生产工具的动物”是决定人之所以为人的特有属性，所以它就成为人的本质属性。要深刻地认识和把握事物、形成有关事物的科学概念，就必须揭示和把握事物的本质属性。 有了对「内涵」与「外延」、本质属性的认识后，我尝试着理解这句话： 内涵是概念所反映的对象的特有属性或本质属性，外延是概念所反映的一类对象，这些对象都具有概念的内涵所反映的属性 内涵是水果所反映的橘子的特有属性或本质属性，外延是水果所反映的一类对象，如这些橘子、苹果等等啊，都具有水果的特有属性或本质属性 ◇概念有哪些种类？搬照概念的种类有哪些？划分标准是什么 根据概念所指称的对象是否具有某种属性，划分为正概念和负概念。如，成年人与未成年人 根据一个概念外延的大小，即指称的对象的数量不同，划分为单独概念和普遍概念。比如，长江与河流。 根据概念所反映的对象是否为一个不可分割的集合体，划分为集合概念和非集合概念。比如，森林（集合）与树木（非集合）。 关于对集合概念和非集合概念的认识： 搬照概念的种类（集合概念与非集合概念） 集合概念是与非集合概念相对的，反映由同类分子有机构成的集合体的概念。如：“工人阶级”、“森林”。 这里的相对，我想其意思应该是指互相对立的两个“面”，就像是大和小是相对的，没有大就没有小；美与丑也是相对的，没有美就没有丑。我能否理解成「不是……就是……」，如「不是集合概念，就是非集合概念」，可是这世界存在一种叫「一般」的东西啊！你的胸大吗？一般。你的相貌如何？一般……这里的「相对」就有种随条件而变化的味道，如篮球和排球的比较，排球就是小的，而排球和乒乓球和相比，那就是排球大啊！随着参照物的不同，这个东西的属性也会发生变化啊！ 还有一点的就是对有机构成的理解：1+1&gt;2 在某一思维对象领域，思维对象可以有两种不同的存在方式 : 一种是同类分子有机结合构成的集合体，另一种是具有相同属性对象组成的类。 而对象集合体与对象类的根本区别是： 集合体的性质，构成集合体的个别对象不必然具有；对象类具有的性质，组成类的个别对象必然具有。 如何区分集合概念与非集合概念呢？ 这关键在于，在一个确定的语境中，一个确定的命题其所表达的性质是整个集体（或整体）才具有的，还是每一个（任意一个）个体都必然具有的。前者叫集合概念，后者叫非集合概念。 举个栗子： 清华大学学生来自五湖四海 。 这个命题中的“清华大学学生”就是集合概念，因为“来自五湖四海”不是每一个个体具有的属性，只有集体总和才具有。 清华大学的学生都是很优秀的。 在这个命题中，“清华大学学生”是非集合概念，因为“都是很优秀的”，其强调每一个分子都必然具有“优秀的”性质。即：对于任何一个x来说，只要是s，就具有p的属性。 从这两个栗子可以看出： 同一个概念在不同的语境中可以是集合概念，也可以是非集合概念。区分是集合还是非集合，其标准在于是否指向一个不可分割的整体。 所以，这一点恰恰体现了 集合概念是与非集合概念相对的 有这么一个常见的栗子，这个于我眼中似曾相识： 鲁讯的著作不是一天能读完的，《狂人日记》是鲁迅的著作，因此，《狂人日记》不是一天能读完的。 这个推理存在逻辑错误： 偷换概念 为什么？ 命题“鲁讯的著作不是一天能读完的”中，“不是一天能读完的”这一性质并不是每一本鲁迅的著作都具有的性质，只有所有鲁迅的著作加在一起的集体才具备这一性质，因此，这一命题中的“鲁迅的著作”这一概念为集合概念。把一个集体具有的性质看作每一个个体都必然具有，这种错误叫偷换概念。 ◇对概念的基本认识 概念有不同的种类，各种概念之间存在着不同的关系；概念是通过语词表达的，概念和语词既有密切的联系，又有本质的区别。逻辑学提供的关于概念的基本知识，是我们正确应用概念的必要条件。 ◇诡辩手法存在着这么一类人，他们叫诡辩论者，而他们在概念应用中的诡辩手法主要有： 玩弄语词游戏，利用歧义词、谐音词混淆概念；故意曲解概念的内涵和外延，以及主观地应用概念的灵活性，等等。 关于对诡辩论者的认识： 在宣传中论证一个命题或说明一个问题时，诡辩论者不去如实地、以有力的逻辑力量揭示事物的内在联系，而是从主观出发，以片面的、表面的、甚至不相干的一些现象制造虚假的联系、因果关系和主从关系，达到混淆是非、颠倒黑白的目的，为其荒谬的言论制造一种骗人的推理形式。 而所谓的诡辩论指的是「违背逻辑规律而做的一种似是而非的推理和论证」。 ★总结 我似乎又跑题了，在查找答案的过程中我迷失了方向 从思维的基本形式的角度来阐释了概念的重要性 任何概念都有两个重要的逻辑特征：内涵和外延 把找到的信息如何有机的结合起来，这是个问题 什么是概念？不知道，按照这篇文章的说法： 概念就是大脑按照一定的方式划分和组织各种意识现象而生成的认识对象。 这句话很不好理解，我想需要继续写一篇「再次认识什么是概念？」的博文 不过，我还是可以强制理解一波的： 简单理解一下，概念就是认识对象，如何认识？有机结合大脑的各种意识现象来认识。]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你该换个角度看球了]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BD%A0%E8%AF%A5%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%90%83%E4%BA%86%2F</url>
    <content type="text"><![CDATA[6月1号，儿童节！小学生库里的球队赢了 我知道这是裁判的锅，这并非是空穴来风，不管是对于火箭来说，还是骑士，总会有一些哨子在关键的时刻对勇士有利，无外乎打乱对方的节奏，比分胶着到最后时为勇士助力……也许裁判也要为勇士建立起王朝打call！况且你也应该知道，在全美，希望勇士输的人的占比远远大于不希望的 本场比赛詹姆斯出战48分钟，投篮32中19，三分7中3，贡献51分8板8助。 又是一个48分钟，而且对老詹能拿51分并不感冒，毕竟如果他真的想得分的话，是很少有人能防得住他的，可是51分确实是很少见了，本以为会一战封神的老詹，在比赛结果出来后，似乎并没有那么起眼了，对，这是一个看结果的时代！呵呵 没有人能忽视你们的努力，骑士队！对方球员不能，裁判不能，全世界的球迷也不能 「输」这个字眼，很有魔力，也许是跟你这辈子最亲近的一个字，之前我写了一篇文章是关于「绿军和骑士的第七场大战」的，这篇文章我是作为胜利者一方来写的，于是，我会带着有怜悯的味道来看待绿军的，而这次我作为输家，来看待比赛的结果，我是很难受的，如果有勇士球迷来怜悯我们家骑士的话，那么结果很有可能是「不需要」。「输赢」说真的，真是件很操蛋的事儿！ 输赢真的有那么重要吗？ 我想我需要去了解一下体育精神是什么？ 体育家精神是指一种追求公平竞争，对于队友和对手谦和有礼，遵守道德，待人真诚，无论输赢始终保持体面的态度。对于此，现代奥林匹克之父皮埃尔·德·顾拜旦曾说过：“最重要的不是输赢，而是参与”，这是对体育家精神的一个经典表述。 我们往往在乎的是输赢，毕竟这是最直观，也是最直接能够得到反馈的，我们都觉得自己很忙，忙到没有时间去了解一个人的过去，确实，这个世界就是如此的 敢问，这个世界存在没有输赢的游戏吗？ 传送门：有没有没有输赢的游戏？ 我的世界算是没有输赢，也没有目标，完全瞎玩 我觉得没有. 输赢的定义如果是”拥有一定的失败条件” 那么沙盒游戏依然会有. 没有输赢的不是游戏.是玩具. 游戏是一定规则下的行为 规则必须指定条件,不符合条件的就算不是输,也是失败. 广义的来说失败就是输. 所以不存在没有输赢的游戏. 但是存在非零和的游戏. 本来问题就是没有输赢的游戏。。 ps：沙盒游戏一种高自由度的游戏，游戏的规则，没有显得那么重要，或者说根本不重要 我们为何会在乎输赢？ 有人说： 不是孩子输不起，而是父母太想赢！ 是父母灌输给孩子的价值观 我从未了解过输赢的定义是什么？ 我只知道，赢了就是高兴一整天，而输了就是难受一整天。我几乎不可能因为「不要在乎结果」这句金句，而让泪水止住，鸡汤没有让我好受些，我也不会为自己熬鸡汤，只有时间方能抹去，可有些输也许一辈子都会牢记于心，久久不能抹去，它们似乎在你的内心扎根了，直到你的心脏停止了，你才会一笑解千愁，原来不过如此…… 我看到了一篇文章，这是对输赢最好的阐述： 传送门：输赢真的不重要？重要的是什么？ 其中的观点： 输的主要5点原因： 态度问题——《摔跤吧！爸爸》里面有一句台词:土地不会自己长出庄稼。只有踏实付出，认真对待，充分的准备，才能把握机会赢得比赛。 无目标——脑子里没有制定要赢的计划。甚至都没有赢的意识，又怎么能赢 没做到持之以恒 ——向达芬奇画蛋那样，坚持再坚持，就会靠近目标，实现梦想 .没有好的学习习惯 ——孩子们都很聪明，习惯会让他们拉开差距。一会抓耳，一会挠头等不良的学习习惯，会分散很多注意力，导致学习低效率。 没有做到学以致用 ——只有把学到的知识灵活地运用出来，理论结合实际，融汇贯通，反复练习，才能熟而生巧。 还真是这么一回事啊 对输赢的态度： 人生中考场处处在，输赢时时有，输赢虽重要，仍需理智的心态去面对。争取赢不骄，败不妥。分析输的原因，总结赢的经验，即看重了结果，也乐在了其中。 输赢相对，需理智对待。赢，是动力；输，检验出不足，也能让我们快速成长。 有输就会有赢，这世界难道就没有没有结果的东西吗？ 这让我想起了墨菲定律 传送门：如何理解「墨菲定律」？ 感谢自己的这个提问，让我减轻了心理负担 为什么？有一个答案，让我觉得很有触动： 很多乱七八糟的答案其实是在不负责任地传播负能量。根本就不理解墨菲定律的本质就在那里误导别人，自己是盲人，也要以盲带盲。这就是知乎的可恨之处。什么叫做坏事一定发生？不谈前提就说一定就是耍流氓。没有前提条件，你想让坏事发生也发生不了。而让墨菲定律成立的前提有两个。一个是大于零的概率。另一个是时间够长。（换句话说是样本够大。）假如少了这两个中的任何一个前提，墨菲定律就不可能实现。举一个例子，一个人一生中只要不是一直关在家里不出去，那么他就有大于零的概率会出现车祸。按照某些人不负责任的解释，那就会给人留下因为会发生车祸，所以一定发生车祸的错误印象。可这真是墨菲定律吗？还是这些人自以为是的墨菲定律呢？话说回来，为什么全世界六十亿人，真正发生车祸的人只有很少一部分呢，为什么墨菲定律在是否发生车祸上对于大多数人来说都不管用呢，对于个人来说，那是因为没满足时间够长这个前提，假如他活个八百岁，八千岁，把万分之一的车祸概率提升到了千分之一，百分之一，自然就很容易发生车祸了。而他要活到八万岁，才能让这概率接近必然实现。可是谁能活那么长，普通人只能活到八十岁，万分之一的概率有多小知道吗，很多人一生中连一百块钱的彩票都没中过，所以对车祸过于恐惧几乎可以说是不必要。只要过马路当心些就好了，假如有些不善于思考的人，看了你们这些乱七八糟的答案，以为坏事一定会发生，那么车祸一定会发生，那就是让这些人背上了不必要的心理负担。所以对于知乎我也想提出一个墨菲定律。那就是由于知乎上不负责任的答案那么多，而又有那么多不爱思考的人，那么，只要使用知乎时间够长，就必定会严重影响这些人的生活质量。因为认知决定着幸福度，知乎上那么多错误的消极的内容，自然有远远大于零的概率让很多人的三观发生扭曲。 墨菲定律成立的两个前提：大于0的概念和时间足够长 我想你一定有这样的想法： 随着生活的进行，被记住的糟心的事情越来越多，顺利的事情统统被忘掉。 所以当你回忆起来，记起来的都是糟心的事情，都是那些不巧的不幸的事情。 所以你下结论，坏事总是会发生。 其实只是坏事总是会被记住。 而在日常生活中，有一些事情需要你重复不停每天做的，一旦次数增多，那么变坏的概率就会得相当大了。 因此，你记住了那些事情变坏的瞬间，你称之为墨菲定律。 ★总结 没有绝对的输赢，只有你怎么看待输赢，你看到输的原因，那就是赢了 善于分辨他人的价值观，即便大多数人都是这样的认为，你也有保持理性，因为真理往往存在少数人手里 你又跑题了，你的题目是「你该换个角度看球了」，所以去找输球的原因，总结赢球的经验，而不是继续抱怨、不服，该打扫这些辣鸡了，至于那些无形的手？你那么喜欢赢就给你赢呗！我不在乎…… 那些让你难以接受的东西发生了，愿你还能勇往直前，直面人生。鸡汤虽好，可仍需自己熬鸡汤，毕竟是不一样的配方、不一样的味道，不然的话，那你很有可能会喝不惯 想的太多？忘记墨菲定律了吗？一直想太多的话，脑子废掉的概率也会增加…… ★参考资料 体育运动 什么是沙盒游戏？有哪些名作？ 孩子论对错，大人论输赢。既然如此为何恋爱时依然注重对方人品？教育孩子依然注重品格？ 孩子为什么会这样在乎输赢]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack和call stack]]></title>
    <url>%2F2018%2F05%2F30%2Fstack%E5%92%8Ccall-stack%2F</url>
    <content type="text"><![CDATA[★引子为什么arguments[0]能拿到事件参数e？ 123btn.onclick = function() &#123; console.log(arguments[0])&#125; 针对这个问题，开始了一段搜索旅行，这段旅行中你会遇到很多个疑问，当然这会加深你对JavaScript的认识…… ★第一段旅行——JavaScript 浏览器事件◇JavaScript、浏览器、事件之间的关系未完待续……]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷路]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[★迷路？笑话 如果发现自己确实迷路了，一定牢记国内外通用的STOP原则，即stay、think、observe、plan，意思分别是待在原地、思考、观察、计划，进行自救。 请记住STOP这个原则，不然你这个路痴，怕是要如崔健的「假行僧」里的歌词一样： 我要从南走到北, 我还要从白走到黑. 我要人们都看到我, 却不知我是谁. 假如你看我有点累, 就请你给我倒碗水. 所以，再说一次，请记住STOP原则——待在原地，打量一下周边，思考应对之策，按计划行事 你能不能抵达目的地，送你8个字： 谋事在人，成事在天 大概的意思是说： 自己已经尽力而为，至于能否达到目的，那就要看时运如何了 也许有时候你不得不信，冥冥之中，有很多事也许是早就安排好的，不过这应该是你该忧虑的吗？ 不去做，未免太无聊了吧！至少多了许多花样 害怕努力了注定得不到想要的结果？ 这是你该忧虑的吗？ 吃饭是为了什么？不吃饭就会GG啊！ 努力是为了什么？为了遇见更好的自己 这不就对了吗？ 结果固然让人欣喜，但你所踩过的坑，都会成为你成长的养分 所以，不要说看到希望了，才去坚持、努力，而是努力了，坚持了，才会看到希望 就如16赛季的骑士由1:3逆转了73胜的勇士，1:3的结果，已经看不到希望了，所以第5场直接放弃吗？不，他们并没有放弃，而是再努力一点，最后逆转夺冠 不要把结果看的比过程重要，你只需要把这次过程给你带来的养分吸收掉就可以了，就这样升级打怪，至于到了最后会不会有惊喜？谁知道呢？毕竟这可不是你此刻该关心的事……]]></content>
      <categories>
        <category>观点与感想</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不能再要求你做的更多]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%8D%E8%83%BD%E5%86%8D%E8%A6%81%E6%B1%82%E4%BD%A0%E5%81%9A%E7%9A%84%E6%9B%B4%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[今天是抢七。对，这是东部的抢七…… 时间的指针拨回到第6场，骑士主场对绿军的比赛。首节，勒夫与塔图姆相撞，疑因脑震荡被迫离场，我已经记不清这是他几次脑震荡了。对，我黑了勒夫，哈哈！ 勒夫下去了，这对绿军是个好机会吗？非也，勒夫意料之外的下场，可以说打乱了绿军计划，而鬼才泰伦卢也一脸懵逼，歪打正着，为抢七的胜利埋下了伏笔…… 比赛就这么进行中，打得很胶着 ，直到末节的1min左右，詹姆斯的2记不可思议的3分，才带走了比赛。 詹姆斯全场打了46min，只有两次休息时间，一次是第三节左后1min，一次是末节最后1min……你不能要求他做的更多了，全场拿下46分，这是他职业生涯生死战的最高分。 赛后，绿军少帅史蒂文斯表示「已经没有赞美之言表示对詹姆斯的称赞了」，对，确实如此，老詹做的足够多了。骑士能赢，全凭自己的一口气吊着，当然也不能忽视其它球员作出的努力，这是一场属于大家的胜利。老詹的态度感染着队友，我想「队友们不做出点行动，怕是对不起老詹哦！」 有时，我在想「老詹你的力量总是无穷无尽，总是会给我们带来惊喜，你一直在进步，即便来到了33岁，依旧是联盟最强的小前锋……你对比赛的态度，对比赛的热情，对对手的尊重，无时无刻都在感染着我。可是你已经33岁了啊，这么努力到底是为了什么？该有的荣誉都有了，还在追求什么呢？」 其实，答案我早就有了。只是，还缺少根稻草…… 对了，绿军少帅史蒂文斯赛后还有一句话让我留下了深刻影响，他是这么说的： 如果你不能在比赛中享受乐趣，你为何还要这样做？那就是我看待这场比赛的方式，那也是他们（指凯尔特人球员）看待这场比赛的方式。 这是比赛应有的态度，同时这也是你人生该有的价值观。 我要装逼了，请准备好纸巾、桶，还有水…… 如果你不能在编程中享受乐趣，你为何还要继续敲demo？那就是我看待编程的方式，那也是大神们看待编程的方式 回到今天这场抢七。 我是不敢看的，真的。我得了一种「凡是看骑士比赛，骑士就会输」的病 好吧！我承认我的小心脏受不起折腾，怕这将是我人生中最后一次观看骑士的比赛，毕竟我没有速效救心丸。 比赛进行着，偶尔我会瞄一眼此刻的比分是多少，而脑子里一直回荡着「该死的，要输了，要输了……我……」，就这样反复着，循环着…… 来到比赛末节，我的心脏开始按照一定的加速度跳动着，由于没有吃早餐的缘故，我的胃有一种绞着的感觉，如比赛的胶着，而脑子开始有点晕了，也许是血糖低的缘故…… 我开始意识到，继续看下去，我真得会GG的。 我决定不继续看下去了。 脑子里一直回荡「骑士领先？还是绿军……天杀的，去你妈的，GG就GG」 我的天，骑士竟然领先了，就这样静静的看着，如老僧入定。我的双手开始颤抖麻木，掩盖不住我来紧张到极致的内心，加上没吃早餐的缘故，这种感觉尤其的强烈…… 我深深的吸了一口气，缓缓地吐了出来 因为结果已经出来了，「87-79」，这是一场防守极其残暴的比赛 我哭了，这是喜极而泣的结果，老詹真的做到了，在勒夫缺阵的情况下，打满48分钟，几乎打出三双，拿下了35分、15个篮板和9次助攻。 同时队友杰夫-格林19分，JR-史密斯12分，特里斯坦-汤普森10分9个篮板。而全队三分球35投9中。 我想到了「即便骑士赢了，最终还是亚军，毕竟绿军可没有一位可以在比赛最后时刻站出来的球员，他们缺少一位真正的球星，而西部就不用说了，不管是火箭的哈登、保罗（受伤，能上场未知数），还是老对手勇士的库里、杜兰特和汤普森，无疑是给骑士亚军的命运给宣告了」 我要喜极而悲吗？不，这不是我的价值观，此时此刻的我，正活在当下，而不应该是现在的我，去思考未来的我。高兴是存粹的高兴，而不是对未来的担忧。尽人事，听天命，所以我什么要「喜极而悲」呢？ 我找到了最后一根稻草，对，找到了 这是骑士和绿军融合起来的稻草，包含着信念、勇气、态度、友爱等等…… 每一滴汗水，只为享受比赛过程中的每一秒，你说为了什么？是为了结果吗？赢了就高兴不已，输了就悲伤不已吗？还是说一个输赢，就能看出你们的努力是不是白费的？ 对，体育似乎只看中结果，你没有赢只是因为你没有比他人更努力，可这样的措辞真得好吗？也许你会认为这可以激励他们更加的努力，但往往会给他们带来的是更多的压力，比赛没有输家，只有为享受与对手竞争的乐趣…… 不能在要求你做的更多了，老詹，同时也不能要求绿军们做的更多了。 这是一场没有输赢的比赛， 只有享受比赛的乐趣…… ps：感恩，让我最美好的青春遇见了你——老詹 对了，我是10年詹蜜 ​]]></content>
      <categories>
        <category>NBA</category>
      </categories>
      <tags>
        <tag>詹姆斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个无缝的轮播]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%A0%E7%BC%9D%E7%9A%84%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[★引子之前写了一个简单的轮播，然而这个轮播有一点不好的就是「滚动最后一张图片的时候，下一张不是直接到第一张图片，而是回退到第一张，才继续滚」，这一点很不好呀！如何做到「下一张是第一张呢？即所谓的无缝呢？」 ★基本的骨架12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="zh-Hans"&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;无缝的轮播&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" media="screen" href="style.css" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="window"&gt; &lt;div class="images"&gt; &lt;img src="./1.png" alt="图片1" width="400" height="300"&gt; &lt;img src="./2.png" alt="图片2" width="400" height="300"&gt; &lt;img src="./3.png" alt="图片3" width="400" height="300"&gt; &lt;img src="./4.png" alt="图片4" width="400" height="300"&gt; &lt;img src="./5.png" alt="图片5" width="400" height="300"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要注意的是，文档的语言为「中文汉字」，我也不知道为啥选择这个，已经被弃用了的，搞不懂老师为啥选用这个，也许是为了兼容性吧！不管了，日后遇到坑再来填！ ★添加样式增加色彩123456789101112131415161718192021222324252627282930313233343536373839404142434445* &#123; margin: 0; padding: 0;&#125;* &#123; box-sizing: border-box;&#125;.window &#123; width: 400px; height: 300px; margin: 150px auto; overflow: hidden;&#125;.images &#123; /* display: flex; */ position: relative;&#125;.images&gt;img &#123; /* 父亲多宽儿子就多宽 */ width: 100%; /* 解决display-inblock的bug, 不写图片有缝隙*/ /* vertical-align: top; */ transition: all .3s; position: absolute; top: 0;&#125;.images&gt;img.current &#123; left: 0; transform: translateX(0); z-index: 1;&#125;.images&gt;img.leave &#123; transform: translateX(-100%); z-index: 1;&#125;.images&gt;img.enter &#123; transform: translateX(100%);&#125; 这里的 box-sizing、 transform需要留意，尤其是 transform这个「魔法师」，我一直认为它有着「动画」的标签，其实不然，它依旧是个静态属性（此时我还真不知道静态属性是个啥概念？），来个题外话： 在网页设计中，CSS被习惯性的理解为擅长表现静态样式，动态的元素必须借助于javascript才可以实现，而CSS3的出现改变了这一思维方式。CSS3除了增加革命性的创新功能外，还提供了对动画的支持，可以用来实现旋转、缩放、平移、扭曲和过渡效果等等，这些功能再一次证明了CSS3功能的强大和无限潜能 …… 关于定位，我一直认为「偏移量怎样也要写两个吧！如：top和left……」 关于 transition，我的理解是「元素发生变化时，需要过渡，即所谓的补间动画，这样一来不会显得生硬和突兀」 回到 transform这个「魔法师」，它的值，即「它所拥有的魔法」，是以函数的形式指定的，称作「功能符」……我不知如何理解这个知识点，是否可以「将就」着？如：这个魔法是能把元素水平平移多少个像素 ★切换状态的行为12345678910111213141516171819202122232425$('.images &gt; img:nth-child(1)').addClass('current')$('.images &gt; img:nth-child(2)').addClass('enter')$('.images &gt; img:nth-child(3)').addClass('enter')$('.images &gt; img:nth-child(4)').addClass('enter')$('.images &gt; img:nth-child(5)').addClass('enter')let n = 1setInterval(() =&gt; &#123; $(`.images &gt; img:nth-child($&#123;x(n)&#125;)`).removeClass('current').addClass('leave') .one('transitionend', (e) =&gt; &#123; $(e.currentTarget).removeClass('leave').addClass('enter') &#125;) $(`.images &gt; img:nth-child($&#123;x(n + 1)&#125;)`).removeClass('enter').addClass('current') n += 1&#125;, 3000)function x(n) &#123; if (n &gt; 5) &#123; n = n % 5 if (n === 0) &#123; n = 5 &#125; &#125; return n&#125; 有个叫「正交」的概念：参考 CSS 为什么这么难学？ 解释一下什么是正交。 你调过显示器的「亮度」、「色调」和「饱和度」吧。 「亮度」就是明暗程度，值越大，屏幕越亮。 「色调」就是颜色，你通过调色调，可以把红色调成绿色。 「饱和度」就是鲜艳程度，值越大越鲜艳。 「正交」就是，你调节这三者中的一个时，不影响其他两个效果。 你调节「亮度」的时候「色调」和「饱和度」不会变化。 你调节「色调」的时候「亮度」和「饱和度」不会变化。 你调节「饱和度」的时候「亮度」和「色调」不会变化。 「正交」看起来应该是理所当然的，对吧。 想象一下「不正交」的情况：你调节「亮度」的时候，「色调」和「饱和度」会跟着无规律的变化。如果是这样，你会调得想死，因为你很难调到你想要的效果。 而 CSS，就是「不正交」的。 我查阅了一下维基百科： 正交 正交是线性代数的概念，是垂直这一直观概念的推广 涉及到线性代数，我就不去深入了解了，因为我缺乏很多基础知识，理解起来不知猴年马月了…… 之所以说正交，是因为这段demo，就很好地体现了「正交」二字，这段demo，不要管CSS-demo，做了什么「背叛」它的事，如「不仅可以让图片水平平移移，还可以是垂直平移等等」，反正JavaScript-demo就不管你CSS-demo做了什么，反正「我」只是对元素切换状态而已，这一点很好地体现了「行为和样式的分离原则」 这里的 one()需要留意一下，很关键，它是指只监听一次事件后，就不监听了 ★优化JavaScript-demo12345678910111213141516171819202122232425262728293031323334353637383940414243let ninit()setInterval(() =&gt; &#123; makeLeave(getImage(n)) .one('transitionend', (e) =&gt; &#123; makeEnter($(e.currentTarget)) &#125;) makeCurrent(getImage(n + 1)) n += 1&#125;, 3000)// 以下就不用看了function getImage(n) &#123; return $(`.images &gt; img:nth-child($&#123;x(n)&#125;)`)&#125;function x(n) &#123; if (n &gt; 5) &#123; n = n % 5 if (n === 0) &#123; n = 5 &#125; &#125; // n = 1 2 3 return n&#125;function init() &#123; n = 1 $(`.images &gt; img:nth-child($&#123;n&#125;)`).addClass('current') .siblings().addClass('enter')&#125;function makeCurrent($node) &#123; return $node.removeClass('enter leave').addClass('current')&#125;function makeLeave($node) &#123; return $node.removeClass('enter current').addClass('leave')&#125;function makeEnter($node) &#123; return $node.removeClass('leave current').addClass('enter')&#125; 这段demo，让我很好理解了所谓的「链式操作」，不管是「移出类」还是「添加类」，其返回值依旧是当前节点 模板字符串的妙用，提供了简单的字符串插值功能，这是比 + 运算符更优雅的语法 这里体现了一个叫做「状态机」的概念，感觉有「高大尚」的影子存在，此时此刻，去理解「状态机」对我有遥远。目前的第一层认识：「当前状态，离开状态，进入状态」 ★总结 最终所呈现的demo，不是一蹴而就的，它会让你踩很多坑后，才会告诉你「这个实现应该长什么样子才比较易懂好理解」 此刻demo有繁琐的味道，此时要优化吗？不需要，把你的思路完整写出来后，才去优化。千万不要在思路还没搞清楚的时候，去优化demo…… 不要去纠结，这个方法是否是最好的，你能快点写demo，就快点写demo…… 今天老詹绝杀了，又是压哨。看来，「一物降一物」是跑不掉了……我在想「即便如此，今年冠军也绝非是骑士的……不过，结果真得很重要吗？享受每一场比赛，不是送给自己最大的礼物吗？」 ★参考资料 语种名称代码 网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？ HTML的lang标记 CSS3中动画属性transform、transition和animation CSS Transform / Transition / Animation 属性的区别 补间动画 JavaScript与有限状态机 状态机编程思想？ ★demo链接 无缝的轮播]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个简单的轮播]]></title>
    <url>%2F2018%2F05%2F01%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[★引子常见的网站多多少少都会有「轮播」的影子，为什么会有轮播呢？因为轮播图是焦点图的优先选择啊！不过，轮播图有时也会带来负面影响，可这是我目前该关心的事吗？ 不问所以然，实现一个简单的轮播…… ★用jQuery实现简单的轮播◇搞一个简单的骨架1234567891011121314151617181920&lt;!-- 搞4张图片 --&gt;&lt;div class="window"&gt; &lt;div class="images" id=images&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ5W5k8pZ4VXyZsIhTEXwtO-P3LmxCEJAlqG74onj4GGXTiMetE1A" alt="" width=284 height=177&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT0ANas9lOWusFru_yrCZ_xHovfxR5saXyrYW0kbKg3jCTe2tMeNQ" alt="" width=284 height=177&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTwXu4i_F3GwAt0P7KtTnSDqjpqaB6xl_v7WzydZY_81moLH2sv" alt="" width=284 height=177&gt; &lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQoGY1n-T9rTSlUHY3XA6Brmv1mWJMHqV7RVD5hLWrMP0ImpS29-Q" alt="" width=284 height=177&gt; &lt;/div&gt;&lt;/div&gt;&lt;span id='buttons'&gt; &lt;span&gt;第1张&lt;/span&gt; &lt;span&gt;第2张&lt;/span&gt; &lt;span&gt;第3张&lt;/span&gt; &lt;span&gt;第4张&lt;/span&gt;&lt;/span&gt; 这里的「alt」我就不给上值了，反正只是测试…… 这里的4张图片，不是百度爬的，是谷歌爬的，百度的会防盗链，即此刻会有用，过段时间这图片链接就不能用了。 给图片加上宽高，这是图片的原始大小「284*177」，其它大小的图可通过Photoshop等工具调整，不过遵循的原则是「不要让图片变形了」。为什么要给定宽高属性呢？如果不给的话，就会触发重排，就像是「一个数组有几百个元素，插入一个元素，意味着，后面的元素会因此而平移一格」，这实在是很消耗CPU，你给定了宽高，则告知此位置的大小是「284*177」，这样一来等加载完图片的时候，就不会影响后面的元素了。好比是一矩形区域划分了10个格，用于停放单车，不多也不少……虽说要遵循「内容样式行为分离」的原则，可这里不需要这样做 ◇添加简单的皮肤1234567891011121314151617181920&lt;style&gt; .images &#123; display: flex; align-items: flex-start; transition: all 0.5s; &#125; .images&gt;img &#123; vertical-align: top; &#125; .window &#123; width: 284px; overflow: hidden; &#125; .red &#123; color: red; &#125;&lt;/style&gt; 这里用到了flex布局，相较于浮动布局，明显少了许多代码，毕竟若用浮动的话，还需要对父元素清除浮动呢 ◇给上行为1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt; // 拿到数据结构，伪数组 var allButtons = $('#buttons &gt; span') // 遍历这个家伙，为其旗下的每个元素都绑定一个点击事件 for (let i = 0; i &lt; allButtons.length; i++) &#123; $(allButtons[i]).on('click', function (x) &#123; // 拿到用户点击的那个元素，虽然target也能做到，但这是在没有事件委托的情况下 // index()得到当前元素排行老几，这是其父元素的范围 var index = $(x.currentTarget).index() console.log(index) // 动态生成平移的值 var p = index * -284 $('#images').css(&#123; transform: 'translate(' + p + 'px)' &#125;) // 解决点击事件与自动播放的冲突 n = index allButtons.eq(n) .addClass('red') .siblings('.red').removeClass('red') &#125;) &#125; // 实现自动播放，取余很关键 // eq()可以根据参数找出对应的DOM，并封装为jQuery对象 // trigger(),触发()中的事件参数，如点击事件 var n = 0; // 拿到按钮个数 var size = allButtons.length allButtons.eq(n % size).trigger('click') .addClass('red') .siblings('.red').removeClass('red') var timeId = setInterval(() =&gt; &#123; n += 1 allButtons.eq(n % size).trigger('click') .addClass('red') .siblings('.red').removeClass('red') &#125;, 1000) // 鼠标移进某个元素，就砸闹钟 $('.window').on('mouseenter', function () &#123; window.clearInterval(timeId) &#125;) // 鼠标移出，就添加闹钟 $('.window').on('mouseleave', function () &#123; timeId = setInterval(() =&gt; &#123; n += 1 allButtons.eq(n % size).trigger('click') .addClass('red') .siblings('.red').removeClass('red') &#125;, 3000) &#125;)&lt;/script&gt; 不是说好，样式行为分离吗？可为啥JavaScript-demo里存在样式？ 如果不这样做呢？设有100张图片，这意味着CSS-demo里需要写100次的「transform: translate(n)；」(n每次增加-284，从0开始)，然后你就简单的使用JavaScript-demo添加「class」,移除「class」。 原则并非绝对坚守，总有例外，利大于弊或弊大于利，请自行斟酌 违反原则，使用JavaScript-demo动态生成样式，这样就不用繁琐的切换状态、移除状态了啊 ★优化demo不优化CSS先，先把JavaScript-demo简单优化一下，如「找到重复的demo，就存在优化的可能」 1234567891011121314151617181920212223242526272829303132333435363738394041424344var allButtons = $('#buttons &gt; span')for (let i = 0; i &lt; allButtons.length; i++) &#123; $(allButtons[i]).on('click', function (x) &#123; var index = $(x.currentTarget).index() var p = index * -284 $('#images').css(&#123; transform: 'translate(' + p + 'px)' &#125;) n = index activeButton(allButtons.eq(n)) &#125;)&#125;var n = 0;var size = allButtons.lengthplaySlide(n % size)var timerId = setTimer()function playSlide(index) &#123; allButtons.eq(index).trigger('click')&#125;function setTimer() &#123; return setInterval(() =&gt; &#123; n += 1 playSlide(n % size) &#125;, 3000)&#125;function activeButton($button) &#123; $button .addClass('red') .siblings('.red').removeClass('red')&#125;$('.window').on('mouseenter', function () &#123; window.clearInterval(timerId)&#125;)$('.window').on('mouseleave', function () &#123; timerId = setTimer()&#125;) 这个demo依旧存在优化的可能，但这需要用到面向对象的知识 整个过程：拿到所有按钮，给所有按钮添加监听事件，按钮被点击了，为「#images」添加样式，同时会激活按钮（如红色）；接着是自动播放的功能，初始化第一个按钮为0，然后播放、设置闹钟循环播放。鼠标移入砸闹钟，鼠标移出，接着播放 这里的每个函数都不超过5行，甚是好懂，除了最上面的那个点击后触发的函数 ★总结 区分拿到的变量是DOM对象还是jQuery对象，为什么？这个API似乎不能用啊！ 有时看懂了他人的demo思路，可自己依旧不会写，依旧想不出来，其实这很正常。为什么？写demo就像是你学写作文一样，如老师布置作业要求写一篇散文，你看人家的散文能看懂，可是轮到自己写了，就GG了。想起高中时，作文都是40分，我就很郁闷了，及格分36分，就多了4分……不管写多少次依旧是40分，难道我不管敲多少次demo，demo水平依旧是原地踏步吗？其实自己根本没有想过如何改变自己的写作风格，依旧是最简单的套路，也许偶尔会有亮点，可这恰恰是某个时刻所谓的「灵感」，而这种「灵感」过去了，就过去了，它不会停留，更不会影响你的写作行为，因为连你也不知道「为什么就写出来了」，借用一句话说就是「我能怎么办？我也很绝望呀！」 所以你可以先尝试着模仿，如「看看朱自清的散文是怎么写的？其他人的散文又是怎么写的？」，这里学习一点，那里学习一点，逐渐地有了自己的风格，也许这需要一年、两年、三年…… 这个学习过程是集大家之所长的，为此才能形成自己的风格。要想自己写出一篇好的散文，做梦！你必须看很多人的散文才可以。同理，demo亦是如此，想要自己写出一个有思路的demo，同样是做梦！你必须有个积淀的过程，这个过程至少需要半年，如这个轮播，你至少需要看3个人是如何实现轮播的，然后你就会发现「咦！大家写轮播都是这么一个套路」，那么你就学会了，以后你写轮播同样根据这个套路来搞。 能否想出新的套路呢？就看你有没有这个灵感了……所以自己想不出怎样写是很正常的 jQuery的API——「trigger()」，自动触发事件，如其参数为 &#39;click&#39;，那么就不需要自己去点击元素才可以触发点击事件了，它会自动触发 需要重新学习一下CSS了 ★参考资料banner和焦点图的区别？ 轮播图这样的交互方式，真的有效吗？ 如何看待“沉浸式阅读/浸入式阅读”一词的流行？ ★demo链接 用jQuery实现简单的轮播]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let，更好的var？]]></title>
    <url>%2F2018%2F04%2F30%2Flet%EF%BC%8C%E6%9B%B4%E5%A5%BD%E7%9A%84var%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 我就喜欢，直接用元素的「id」作为DOM对象。这样操作极其方便，不用每次都要「document.get……」，这让我少写了许多个字符。难道这样用真得没有bug吗？ ★使绊子​ 你不是很喜欢，用「id」作为DOM对象吗？那好，这个元素的「id」值为「alert」，你猜打印的结果： 12345678910&lt;body&gt; &lt;div id="alert"&gt;Hello!World&lt;/div&gt; &lt;div id="x"&gt;我是「x」&lt;/div&gt; &lt;script&gt; var xHtml = x.textContent var alertHtml = alert.textContent console.log(xHtml) console.log(alertHtml) &lt;/script&gt;&lt;/body&gt; 不是显而易见吗？ 一个是『我是「x」』；一个是「Hello!World」； 你确定？有时候你会存在一些错误的认识，至今未尝发觉，你总以为别人都是这样做的，自己照着做总没错吧！而且也拿到了自己想要的结果，可是你有没有想过，这样用，也许存在「大前提」呢？ 那好吧！我就运行一下，看一下结果，证明小白我是正确的 结果： 12我是「x」undefined 此时此刻的你，大写的一脸懵逼……心里一连串的问号——问号三连 为什么？我不服，我不服……为什么「x」可以，而「alert」却不可以。明明就只有名字不同，难道连名字也是一种罪过吗？ 你打印一下「window」 1console.dir(window) 会发现window旗下并没有「x」这个key，却可以使用「x」 如可以这样： 12window.xwindow['x'] 对于「alert」来说，「alert」一直是全局属性，一直在window旗下 这意味着，如果你想要快捷地用「id」获取DOM对象的话，那么「id值」就不能与window旗下的全局属性冲突 可是window旗下并没有显示「x」这个key啊！却可以使用…… 为什么？没有探究的必要了，在我看来……有些东西不需要如此执着，就比如你这个，你可以假设很多答案，如：「控制台打印的东西有问题」……「window的第一层找不着就到其旗下的document里去找，然后找到」 如果非要找出个所以然，可以看一下stackoverflow的回答： Do DOM tree elements with ids become global variables? ★全局变量可耻，不能用​ 平时用x/y/……等避开了window的属性，才能通过「id值」直接拿到对应的DOM元素对象。可是如果没有避免呢？那该如何拿到这个DOM对象？ ◇无所畏惧，拿到DOM对象​ 随意起了一个名字，叫「alertDom」 12var alertDom = document.getElementById('alert')console.log(alertDom) 这是通过DOM提供的API拿到的对象，还以其它API也可以拿到，如： 12var alertDom1 = document.querySelector('#alert')console.log(alertDom1) ◇有所畏惧，alert()不能用了​ 我声明了一个变量叫「alert」 123var alert = document.getElementById('alert')console.log(alert)alert('你能看到我吗？') 结果报错了： alert is not a function 这个声明的变量是全局变量，它与window旗下的alert冲突了，说白了，就是覆盖了它 所以，你还是不要用全局变量好了，起个名字真费劲 ★全局变量？局部变量◇唯函数，方能成为局部变量​ 我们可以使用局部变量，以防和window的全局属性冲突了 123456function y() &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;y()console.log(window.alert) 可见全局的alert依旧是它，同时我们也得到了想要的alert值，即这个#alert元素 可是问题又来了，关于函数的名字，函数的名字也是全局变量啊！它也会存在冲突的可能性的 一个问题套着一个问题，如此反复…… ◇被忽视的函数名​ 函数名，作为全局变量的一份子，那么只好去掉了，改为匿名函数。可是如何调用匿名函数呢？难道还是这样子么 var fn = function(){}？这岂不是进入死循环了啊！ ★立即执行函数表达式（IIFE）◇立即执行函数​ 函数匿名了，可以立即执行吗？ 1234function() &#123; var alert = document.querySelector('#alert') console.log(alert)&#125; () 结果，报语法错误： Unexpected token ( 为什么？ 注意，这是前面的function()出错先 当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的function关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。 注意： var foo = function(){console.log(1)}()这样是可以立即调用的 如果是有名字的函数声明，然后立即调用呢 function foo(){ /* code */ }();//SyntaxError: Unexpected token 为什么？ 当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。 毕竟圆括号里并没有表达式，你直接敲下 ()也是会报语法错误的 那加个参数，可以吧 12345678//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：function foo()&#123;/* code */&#125;(1)//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:function foo()&#123;/* code */&#125;(1); 具体测试一下： 123456789101112131415161718var a = function foo(f)&#123; console.log(f);return f&#125;(1); //1console.log(a) //1var b = function foo(f)&#123; console.log(f)&#125;(1);console.log(b) //undefinedfunction foo()&#123; console.log(1)&#125;(2); //2function foo(f)&#123; console.log(f);console.log(3)&#125;(2); //2var k = function zzz(f)&#123;console.log(5);console.log(f);return 7&#125;(3)//5 3k //7var q = function qqq(f)&#123;console.log(5);console.log(f+1);return 7&#125;(3)//5 4q //7var t = function foo(f)&#123; console.log(f)&#125;(1);//1t //undefinedvar z = function(f)&#123;return f&#125;(5)z //5 ◇立即执行函数表达式​ 如何去掉匿名函数立即执行的语法错误？错误的本质在于，语法分析器看到了 function这个关键字，于是认为，你这个函数声明是没有名字的啊！于是就报错了 如何解决？ 将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 function关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。 所以可有： 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。 当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。 测试demo： 12345678(function () &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;)()(function () &#123; var alert = document.querySelector('#alert') console.log(alert)&#125;()) 注意：括号放在哪也是有区别的，虽然结果一致 前者是「括号内的表达式代表函数表达式」 后者是「括号内的表达式代表函数立即调用表达式」 可见，函数名字没了，局部变量有了，而且还有立即调用 除了添加圆括号，还有别的方式吗？ 如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节 1234!function()&#123;/* code */&#125;();~function()&#123;/* code */&#125;();-function()&#123;/* code */&#125;();+function()&#123;/* code */&#125;(); ★使用let​ JavaScript很奇葩，为了使用局部变量，需要搞个函数，然后还要匿名，还要立即执行，立即执行报语法错误，于是，还得告诉浏览器我这个函数不是声明的 为此，JavaScript升级了 理论上，在JavaScript眼中，demo块是没有作用域的，但是升级了，就有作用域了。这个作用域的有无，是「let」和「var」决定的，即let眼中是有的，而var则无视 测试demo： 1234567891011// var的姿势：&#123; var alert = document.querySelector('#alert') console.log(alert)&#125;// 等价于：var alert&#123; alert = document.querySelector('#alert') console.log(alert)&#125; 这个alert还是会跑出去，成为一个全局变量，把window的alert给覆盖了，即「块」是包不住var的，于是就用了IIFE 而let是怎样的呢？ 123456789101112131415&#123; let alert = document.querySelector('#alert') console.log(alert)&#125;&#123; let a = 1&#125;// console.log(a)//a is not defined let b = 2&#123; let b = 3&#125;console.log(b)//2 ​ let的姿势：let也不会提升，在哪声明就在哪声明，不会变量提升；能认识这个let只有在这个块里面了，出了这个块就没人认识它了 ES6之前想要用局部变量，只好用立即执行函数表达式了，ES6出来后就，不需要了，毕竟有let这个神器 ★总结 若对元素设置id属性，值为「x」的话，那么可以通过window.x或者window[&#39;x&#39;]引用该元素，而不是使用DOM的API去获取该元素的DOM对象，而且这用的用法写入了html5规范 最好不要使用全局变量，毕竟很容易导致命名冲突，或者说是变量污染 要想使用好局部变量，用两种方式可以做到：一是立即执行函数表达式（IIFE）；二是使用ES6的语法let 一个这样的问题「直接拿元素id的值，并没有得到该元素的DOM对象」引发出了，好几个知识点，如「let和var」、「IIFE」、「function关键字」…… 若是放表达式的圆括号 ()，必须给上表达式，不然会报语法错误 ★参考资料 DOM概述 DOM对象 [译] JavaScript：立即执行函数表达式（IIFE） 直接使用id引用DOM元素 为什么要有js立即执行函数，存在的意义是什么？ JavaScript中var、let、const区别？ 函数声明和函数表达式的区别 ★demo链接 使用let的测试demo]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery不过如此？]]></title>
    <url>%2F2018%2F04%2F27%2FjQuery%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[★引子​ 你说我该如何学习jQuery？这个……先学着先吧！ ★你是几个意思◇我要封装一个函数​ 哦！你是要写个函数，对吧！ ◇我要一个命名空间​ 我想，你要为一个对象取一个名字，是不是，小白？如果是的话，叫「小花」不错，我表示强烈建议！就像是这样： 12var 小花 = &#123;&#125;小花.getWechat() 这个小花就是「命名空间」，旗下有个要自己实现的「得到小花微信号」的方法 如果要关联jQuery的话，那就这样： 123var dom = &#123;&#125;dom.getSibling(node) //得到节点的兄弟姐妹元素dom.addClass(node, &#123;a: true,b: false&#125;) //根据true/false,为节点添加类名 ​ 这里的dom同样是个命名空间，把封装好的函数，取其函数名，放在dom下面，那么，这个命名空间才有它存在的意义。其实说白了，命名空间就是个对象呗！这个对象，给了函数，生活的空间。所以你应该知道你要的是什么了吧！ ◇我需要一个API我觉得你是想要一个别人提供给你用的函数 ★我需要一些套路◇封装一个函数的正确姿势 随意起名 理清输入输出 改个好听的名字 ◇优化代码 如果出现类似的demo就存在优化的可能 ★jQuery是啥？我不知道◇自己封装两个函数得到节点item3的兄弟姐妹1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;ul&gt; &lt;li id="item1"&gt;选项1&lt;/li&gt; &lt;li id="item2"&gt;选项2&lt;/li&gt; &lt;li id="item3"&gt;选项3&lt;/li&gt; &lt;li id="item4"&gt;选项4&lt;/li&gt; &lt;li id="item5"&gt;选项5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function getSiblings(node) &#123; // 得到爸爸的所有的儿子，包括我 var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125; console.log(getSiblings(item3)) //&#123;0: li#item1, 1: li#item2, 2: li#item4, 3: li#item5, length: 4&#125; &lt;/script&gt;&lt;/body&gt; 给节点item3添加3个class 第一种方式：简单直接法 1234567// 添加类a、b、c//简单粗暴添加item3.classList.add('a')item3.classList.add('b')item3.classList.add('c')// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第二种方式：遍历添加法 1234567 //通过数组的方式 var classArray = ['a','b','c'] classArray.forEach(value =&gt; &#123; item3.classList.add(value) &#125;);// &lt;li id="item3" class="a b c"&gt;选项3&lt;/li&gt; 第三种方式：集「添加和移除」于一身法 123456789101112131415 // 第3种更强大法： var classHash = &#123; 'a' : true, 'b' : false, 'c' : true &#125; for(let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;//&lt;li id="item3" class="a c"&gt;选项3&lt;/li&gt; 封装为函数 得到封装好的addClass： 1234567891011function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] if (value) &#123; item3.classList.add(key) &#125; else &#123; item3.classList.remove(key) &#125; &#125;&#125;addClass(item3, classHash) ◇优化addClass你是一个对象，想要调用一个方法，有两个姿势： 12obj.x()obj['x']() 所以可有： 12345678function addClass(node, classHash) &#123; for (let key in classHash) &#123; var value = classHash[key] var methodName = value ? 'add' : 'remove' node.classList[methodName](key) &#125;&#125;addClass(item3, classHash) ◇关联这两个API为什么需要关联?​ 这两个API都是在操作节点，一个是得到节点的兄弟姐妹；一个是为节点添加/移除class。而DOM的API都在document旗下。所以，依葫芦画瓢，我们同样也可以这样做。 如何关联？​ 在window旗下，命名一个叫小花的空间，然后在小花旗下，绑定这两个API 12345window.小花 = &#123;&#125;小花.getSiblings = getSiblings小花.addClass = addClass小花.getSiblings(item3)小花.addClass(item3, &#123; a: true, b: false, c: true &#125;) 为什么要用「小花」这个命名空间？ 这两个API谁写的？翠花写的，你确定？ 我写了几十个API，厉害吧！厉害，我每次要用你API的时候，都不知去哪儿找，就像是无招牌的店，听说有家店做的「藤条焖猪肉」特别好吃，可是在哪？ 为什么，我引入你写的API，我写的那些demo，出bug了，即把人家的全局变量给覆盖了。他人，一定发誓，我一定不会再用你写的API了，发誓三连…… 用了命名空间，就不会让声明式的函数写法，覆盖了他人的全局变量 ◇能不能把 node 放在前面比如说这样： 12node.getSiblings()node.addClass() 给出两种方法 第一种扩展 Node 接口​ 直接在 Node.prototype 上加函数，函数里this很是关键 12345678910111213141516171819202122Node.prototype.getSiblings = function () &#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;Node.prototype.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; this.classList.add(value) &#125;);&#125;item3.addClass(['a', 'b', 'c'])console.log(item3.getSiblings()) ​ 如果你不能理解这个this表示的是什么，可以这样： 12item3.addClass.call(item3,['a','b','c'])console.log(item3.getSiblings.call(item3)) call()的第一个参数，就是this。有些时候，demo虽然简洁了许多，可是理解起来也会难上几分，就如这个this一样，调用函数是方便了，可是却不好理解这个this，为啥指向调用者？ 请记住：this是call的第一个参数。 你他妈不明白this是因为你他妈不用call 第二种新的接口 BetterNode​ 从构造函数着手，Node的升级版，也叫「无侵入」 12345678910111213141516171819202122232425262728293031// Node的升级版：window.Node2 = function (node) &#123; return &#123; getSiblings: function () &#123; var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; // 去掉我 for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125;, addClass: function (classArray) &#123; classArray.forEach(value =&gt; &#123; node.classList.add(value) &#125;); &#125; &#125;&#125;var node2 = Node2(item3)console.log(node2.getSiblings())node2.addClass(['a', 'b', 'c'])console.dir(node2) ◇把 Node2 改个名字吧如这样： 123456789101112131415function jQuery(node)&#123; return &#123; element: node, getSiblings: function()&#123; &#125;, addClass: function()&#123; &#125; &#125;&#125;let node =document.getElementById('x')let node2 =jQuery(node)node2.getSiblings()node2.addClass() ◇再给个缩写吧 alias1window.$ = jQuery ◇改进jQuery可传入选择器字符串12345678910111213window.jQuery = function (nodeOrSelector) &#123; let node // 特性检测 if(typeof nodeOrSelector === 'string') &#123; node = document.querySelector(nodeOrSelector) &#125; else &#123; node = nodeOrSelector &#125; return &#123; getSiblings: function () &#123;……&#125;, addClass: function (classArray) &#123;……&#125; &#125;&#125; ​ 这里用到了闭包，getSiblings和addClass都用到了node，那么它们就构成了一个闭包。不会说，你调用了这个jQuery函数完毕后，然后局部变量node存储的值就被释放掉了，由于这个局部变量跟返回值对象中的任意一个方法（或者说是函数）构成了闭包，这意味着就像是「全职猎人中酷拉比卡为了获取强大的力量，把它念能力实质化的锁链，跟自己的心脏绑在一起了」。如果释放掉，那么这个对象返回值，没有任何意义。「没有把念能力跟自己的心脏绑定在一起，就无法获得强大的力量，何谈去复仇旅团呢？」 就像是这样： 有时候，你问为什么局部变量没有被释放掉？回答说「闭包」啊！可是你依旧产生了质疑，如「函数调用栈不是入栈然后出栈吗？一念生一念死，为啥还会有记忆……」。其实你可以反问自己，「为啥调用函数的时候，会有调用栈的概念？」「为啥调用函数的时候，会有闭包的概念？」 他妈的说白了「概念不会凭空产生，它的存在总有它存在的意义，也许合理也许不合理，它总有一个理由，占着茅坑不搞事」，简而言之，就是「哥的世界你不懂，45度角仰望天空……」 如果你觉得复杂了，就是没有想清楚 如果你觉得闭包很复杂，那么我想你需要静静，不要去想它…… 操纵多个节点123456789101112131415161718192021222324252627282930window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123;&#125; //类型检测： if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) //伪数组 for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; nodes.getSiblings = function () &#123; &#125; nodes.addClass = function (classArray) &#123; classArray.forEach(value =&gt; &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].classList.add(value) &#125; &#125;) &#125; return nodes&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue']) 添加读写文本的API123456789101112131415161718nodes.text = function (text) &#123; if (text === undefined) &#123; var texts = [] for (let i = 0; i &lt; nodes.length; i++) &#123; texts.push(nodes[i].textContent) &#125; return texts &#125; else &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; nodes[i].textContent = text &#125; &#125;&#125;var node2 = jQuery('ul&gt;li')node2.addClass(['blue'])console.log(node2.text())node2.text('hi') ★jQuery初探◇调用jQuery这个函数jQuery是框架还是库？ Framework 帮你设计架构，而 library 帮你写代码。所以jQuery是库，不是框架。 初始化网页文档：要引入jQuery库 骨架： 123456789&lt;body&gt;&lt;ul&gt; &lt;li&gt;第1项数&lt;/li&gt; &lt;li&gt;第2项数&lt;/li&gt; &lt;li id='item3'&gt;第3项数&lt;/li&gt; &lt;li&gt;第4项数&lt;/li&gt; &lt;li&gt;第5项数&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 行为： 1234var nodes = jQuery('ul&gt;li')console.dir(nodes)var dd = jQuery()console.dir(dd) 结果： 可见这个jQuery库是把其API写到Object的原型里去的，这样一来就不用浪费资源了 ◇依旧可以使用DOM API 行为： 123var item3 = jQuery('#item3')console.dir(item3)item3[0].classList.add('blue') 只不过jQuery返回的是伪数组，所以你需要添加下标才可以，不过即便如此，我想你也不想用DOM API了吧！ ◇使用一些API 添加类、移除类：只是追加，不会覆盖掉原来的。移除后回到默认的蓝色 12item3.addClass('red')item3.removeClass('red') 链式操作：移除单前类，再添加，相当于是覆盖； 12item3.removeClass('blue').addClass('red')item3.removeClass('red') 移除红色后，没有回到蓝色 开关 添加2个button元素： 12&lt;button id='x'&gt;X&lt;/button&gt;&lt;button id='y'&gt;Y&lt;/button&gt; 鼠标点击按钮，就会切换item3的字体颜色： 123x.onclick = function() &#123; item3.toggleClass('yellow')&#125; 效果就像是，天黑开灯，睡觉关灯 为多个元素添加不同的类： 1234567var classes = ['blue','red','yellow','green','yellowgreen']y.onclick = function() &#123; nodes.addClass(function(index,currentClass) &#123; return classes[index] &#125;)&#125; ★jQuery不过如此？ jQuery 在兼容性方面做得很好，1.7 版本兼容到 IE 6 jQuery 还有动画、AJAX 等模块，不止 DOM 操作 jQuery 的功能更丰富 jQuery 使用了 prototype，我们没有使用，需要new的知识点 ★总结 在非迫不得的情况下，不需要自己写操作的页面API，毕竟你没有jQuery做的好，如兼容问题 如果要想操作页面，目前jQuery就能很好地满足，其它同类型的库没有必要引入 拿到一个节点或多个节点，然后调用API，我想这就是使用jQuery 如果是jQuery对象，那么接收的变量最好加上个\$，以免混淆 了普通的DOM对象，如 var $node = jQuery(&#39;ul&gt;li&#39;) 如何看jQuery文档？先记住一些常见的关于其API的单词，然后学会一个API如何使用后，根据需求去使用API。如果没有理解这个API关于中文的概述，那么试着看看它的英文 jQuery很不简单，但我们的使用是简单的，不然，也不会红了那么多年 ★参考资料jQuery 是库（library）还是框架(framework)? jQuery中.addClass()和.removeClass()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个jQuery的API]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjQuery%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[★引子​ 经常用jQuery库的API，真的好吗？为何自己不尝试着实现一个jQuery的API…… ★想要实现的功能 将当前文档中所有 div 的 class 都添加一个 red 将当前文档中所有 div 的 textContent都 变为 hi ★如何实现◇搞一个基本的测试骨架12345&lt;div&gt;我是1div&lt;/div&gt;&lt;div&gt;我是2div&lt;/div&gt;&lt;div&gt;我是3div&lt;/div&gt;&lt;div&gt;我是4div&lt;/div&gt;&lt;div&gt;我是5div&lt;/div&gt; ◇给上简单的皮肤12345&lt;style&gt; .red &#123; color: red; &#125;&lt;/style&gt; ◇按你想要的实现行为定义一个全局变量1window.jQuery = function (nodeOrSelector) &#123;&#125; 这个全局变量是个函数，形式参数可为「节点」或「选择器」，总而言之即是可传入节点对象或字符串。 之所以定义一个去全局变量，是为了有个命名空间，好让自己所写的API都归于jQuery旗下 开搞函数体声明一个局部变量1let nodes = &#123;&#125; 这个局部变量很重要，它是个伪数组 特性检测123456789101112if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; nodes.length = temp.length&#125; else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125;&#125; 需要判断传入的参数是啥类型的？假如是字符串，注意这个字符串是选择器，根据选择器得到一个节点组成的伪数组，遍历它，把它扔到局部变量里去，这样就可以砍掉多余的NodeList接口 如果实参是Node的实例的话，那么nodes就只有一个元素了 添加「addClass」API12345nodes.addClass = function (className) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].classList.add(className) &#125;&#125; 添加「setText」API12345nodes.setText = function (text) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].textContent = text &#125;&#125; 返回值1return nodes ◇测试写的API12345window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 这里搞了个别名$ 「实现一个jQuery的API」的github源码 ★总结 实现两个API是否用到了闭包 我是用this访问的，所以没用到闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
